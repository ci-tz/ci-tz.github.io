<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Improving File System Performance of Mobile Storage Systems Using a Decoupled Defragmenter</title>
    <link href="/2024/03/17/Improving-File-System-Performance-of-Mobile-Storage-Systems-Using-a-Decoupled-Defragmenter/"/>
    <url>/2024/03/17/Improving-File-System-Performance-of-Mobile-Storage-Systems-Using-a-Decoupled-Defragmenter/</url>
    
    <content type="html"><![CDATA[<h2 id="对闪存存储的文件碎片化进行表征研究">对闪存存储的文件碎片化进行表征研究</h2><h3 id="碎片程度的定义">碎片程度的定义</h3><ul><li><strong>逻辑碎片程度 (DoFL)</strong>：文件x分配的范围数与文件x所需最少范围数之比。</li><li><strong>物理碎片程度 (DoFP)</strong>：顺序访问文件x时的平均I/O并行度与闪存存储系统支持的最大I/O并行度之比。</li></ul><h3 id="实验设计">实验设计</h3><p>通过模拟一年和一周的工作负载，测量Ext4文件系统老化后的DoFL和DoFP值的变化，以了解逻辑和物理碎片在闪存存储中的相互作用。</p><h3 id="结果与分析">结果与分析</h3><p>根据实验结果显示的图像，我们观察到两个区域：</p><p><img src="image-20240317224436449.png" /></p><ul><li><p><strong>区域A</strong>：表示逻辑碎片化程度高，但物理碎片化程度不高的文件比例。</p></li><li><p><strong>区域B</strong>：表示物理碎片化程度高，但逻辑碎片化程度不高的文件比例。</p></li><li><p><strong>结论</strong>：逻辑碎片和物理碎片是高度解耦的。即逻辑碎片化与文件在闪存上能否充分利用并行度并没有必然联系（这个结论与FAST 24的Best Paper本质上是相符的）</p></li></ul><p>逻辑碎片化和物理碎片化对I/O性能的影响不同：逻辑碎片化会增加系统软件I/O堆栈的开销，而物理碎片化会降低闪存中的I/O并行性。因此作者提出，文件碎片化整理工具既需要再逻辑上整理文件碎片，又需要在物理闪存上整理碎片。</p><h3 id="逻辑碎片化对性能的影响">逻辑碎片化对性能的影响</h3><p>作者测量了不同DoFL和DoFP下读取文件的性能。结果表明，随着DoFL的增加，读取性能降低。</p><p><img src="image-20240317224710865.png" /></p><p>作者还对DoFL从1（无碎片）到8（大量碎片）的I/O执行时间进行了测试。结果显示，块层和设备驱动程序的时间随DoFL值的增加而增加，而文件系统和页面缓存层的时间几乎没有受到影响。这暗示了逻辑碎片化对系统的影响主要体现在块层和设备驱动程序中。但让我感到疑惑的一点是：<strong>为什么在他给出的结果中，闪存消耗的时间竟然比块层消耗的时间还要少？</strong></p><p><img src="image-20240317224755097.png" /></p><h3 id="物理碎片化对性能的影响">物理碎片化对性能的影响</h3><ul><li>根据上一节给出的测试中可以得出，在相同DoFL下，物理碎片化程度越高，读取性能也越差</li><li>但作者根据碎片化表征研究中的结果认为，<strong>大部分文件的物理碎片化程度较少</strong>。因为闪存存储内部有丰富的 I/O 并行性，文件不太可能遭遇极低的 I/O 并行性。</li></ul><h2 id="解决方案">解决方案</h2><p>提出了一个用户层工具，分别在逻辑和物理上对文件碎片进行整理，但以逻辑整理为主。</p><figure><img src="image-20240317224936033.png" alt="" /><figcaption>整体设计</figcaption></figure><h3 id="逻辑碎片整理">逻辑碎片整理</h3><p>主要过程为：①对当前文件系统中所有文件的逻辑碎片化情况进行监控，筛选出逻辑碎片化程度较高的文件列表。②向闪存FTL发送碎片整理命令。③FTL执行映射表的重映射，然后将更新后的逻辑块地址（LBA）返回给文件系统，以便文件系统进行相应的LBA更新。</p><p>FTL映射表更新及文件系统更新过程如下图所示：</p><figure><img src="image-20240317225124426.png" alt="" /><figcaption>FTL重映射</figcaption></figure><p>由于闪存页中OOB的反向映射无法修改，因此为了掉电恢复，会将LBA重映射的信息写入到闪存中。掉电恢复过程如下图所示：</p><figure><img src="image-20240317225137309.png" alt="" /><figcaption>掉电恢复</figcaption></figure><p>当FTL更新映射完成，文件系统修改LBA成功后，会在Defrag Log后添加一个commit标志，以便掉电恢复时roll back。</p><p>若文件内容因为GC被移动到新的物理位置，则会更新相应的映射表信息和日志：</p><figure><img src="image-20240317225149990.png" alt="" /><figcaption>GC</figcaption></figure><h3 id="物理碎片整理">物理碎片整理</h3><p>略，此部分不是本文重点</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSD</tag>
      
      <tag>Fragmentation</tag>
      
      <tag>Defragmentation</tag>
      
      <tag>File System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>We Ain’t Afraid of No File Fragmentation: Causes and Prevention of Its Performance Impact on Modern Flash SSDs</title>
    <link href="/2024/03/17/We-Ain%E2%80%99t-Afraid-of-No-File-Fragmentation-Causes-and-Prevention-of-Its-Performance-Impact-on-Modern-Flash-SSDs/"/>
    <url>/2024/03/17/We-Ain%E2%80%99t-Afraid-of-No-File-Fragmentation-Causes-and-Prevention-of-Its-Performance-Impact-on-Modern-Flash-SSDs/</url>
    
    <content type="html"><![CDATA[<h2 id="文件碎片分析实验">文件碎片分析实验</h2><ul><li><p><strong>实验目的：</strong> 探究文件碎片对性能的影响，并分析主机端和设备端对性能的影响程度。</p></li><li><p><strong>实验平台</strong>：</p></li></ul><p><img src="image-20240317164419909.png" /></p><ul><li><strong>文件系统</strong>：ext4</li><li><strong>实验方法</strong>：<ul><li>在每次实验运行之前关闭page cache；</li><li>使用nr_requests参数来调整I/O队列深度，每个实验重复10次；</li><li>创建不同碎片程度的文件：DoF（ actual number of extents to the ideal number of extents）<ul><li>每个文件的总大小：8MB；</li><li>具体方法：关闭ext4的延迟分配和块预留优化；写一段target file的内容，然后再写一段其他文件的内容；使target file 碎片之间的偏移保持在8MB。例如，要生成DoF=4的target file，那么该文件的每个碎片大小为8MB / 4 = 2MB；并且要保持每个碎片之间的距离为8MB，因此需要先写2MB的target file，然后再写6MB的其他文件，重复4次即可。</li><li>DoF范围从1到256</li></ul></li></ul></li><li><strong>结果一</strong>：证实文件碎片化会影响性能</li></ul><p><img src="image-20240317164632495.png" /></p><ul><li><strong>结论</strong>：<ul><li>文件碎片化会导致性能下降</li><li>队列深度小会导致更明显的性能下降</li></ul></li></ul><p>下面需要探究是主机端软件层影响更大还是设备端影响更大</p><h3 id="主机端探究">主机端探究</h3><ul><li><strong>实验设置：</strong> 主机端不变，设备端使用ramdisk</li></ul><p><img src="image-20240317164709500.png" /></p><ul><li><strong>结论：</strong> 队列深度为1时会出现性能下降，但当队列深度较大时，几乎没有性能下降。<ul><li><strong>深度为1时性能下降的原因：</strong><ul><li>测量 __x64_sys_read 函数在 DoF 变化时分别创建 iomap、bio 和request结构所需的时间。</li><li>结论：iomap和request结构的创建时间增加，bio的时间变化不大</li></ul></li><li><strong>深度为128时性能下降不大的原因：</strong><ul><li>使用blktrace测量request结构体创建以及ramdisk访问的延迟（DoF=128,队列深度=128）。</li><li>结论：由于内核中的plug进程，创建request的时间会被ramdisk读取之前request的时间掩盖，所以在队列深度较大时，性能下降并不明显。</li></ul></li></ul></li></ul><figure><img src="image-20240317164746483.png" alt="" /><figcaption>iomap/bio/request结构体创建时间</figcaption></figure><figure><img src="image-20240317164818596.png" alt="" /><figcaption>request结构体创建与ramdisk读取</figcaption></figure><h3 id="设备端探究">设备端探究</h3><ul><li><strong>研究对象</strong>：接口（SATA/NVMe）+设备内部的性能</li><li><strong>实验方法</strong>：<ul><li>从裸盘中读取8MB的连续文件，排除文件系统和内核I/O路径的影响。</li><li>读取单位从32KB增加到8MB，每次都扩大一倍。</li><li>每次测试之前都将SSD 全部trim，并且对要读的区域执行顺序写。</li></ul></li><li><strong>测试结果：</strong></li></ul><p><img src="image-20240317164935077.png" /></p><ul><li><strong>结论</strong>：<ul><li>当设备的队列深度设置为1时，随着读取单元的减小，读取性能下降</li><li>当队列深度较大时，性能变化不明显</li></ul></li></ul><h3 id="总结论">总结论</h3><ol type="1"><li>文件碎片化对主机端软件开销影响不大，并且由于队列异步，其实际开销还会大大减少。</li><li>当请求分割出现时，若采用多队列，主机接口+设备内部的开销也不明显。</li><li>当前系统中默认均为多队列设置，因此实际上请求分割并非导致总体性能下降的主要原因。</li></ol><h2 id="文件碎片化导致性能下降的真正原因">文件碎片化导致性能下降的真正原因</h2><ul><li><p><strong>问题阐述：</strong> 文件碎片化在SSD内部引起芯片级冲突，从而影响读取性能。这种冲突会导致读取操作只能在部分芯片上进行，加重了读取时间。</p></li><li><p><strong>模拟芯片级冲突：</strong></p><ul><li>假设一个SSD以4KB页面的循环方式向16个芯片分配存储空间。</li><li>如果连续写入1MB数据（256页），然后每隔一页读取一次（128页），读取操作只能发生在一半的Die上。</li><li>这样会导致芯片级冲突加倍，从而使读取128页的时间几乎翻倍。</li></ul></li></ul><p><strong>测试方案及结果：</strong></p><ul><li><p><strong>测试方案</strong>：使用FIO进行测试，设置读取粒度为4KB，每次读取间隔与上一次保持固定值(alignment size)。</p></li><li><p><strong>测试结果</strong>：</p></li></ul><p><img src="image-20240317165103860.png" /></p><ul><li><p>NVMe-A在对齐粒度为64KB时首次出现性能下降（对应于只用到1/2 Die的情况），表明每次分配32KB的数据到一个Die上。在对齐粒度为1024KB时性能最差，因此可知NVMe-A的stripe size为1MB。</p></li><li><p>对于NVMe-B，其die分配粒度为32KB，但条带大小为512KB。</p></li><li><p>超过条带大小后，性能下降与alignment size % stripe size相同，因此会呈现出对称的性能曲线。</p></li><li><p><strong>结论</strong>：</p><ul><li>文件碎片导致的性能损失主要是由SSD内部的芯片级冲突引起的。</li><li>与可以通过增加I/O队列深度来隐藏的I/O路径延迟或接口开销不同，芯片级冲突导致的性能下降会持续存在。</li></ul></li></ul><h2 id="解决方案">解决方案</h2><p>根据上述分析，可以得出结论：逻辑层的文件碎片化与读取性能下降并非密切相关。实际上，读取性能下降主要源于page-to-die的不合理映射，从而导致die级冲突。换言之，即使文件存在碎片化，若page和die之间的映射得当，性能不会受到太大影响；反之，即使文件未碎片化，若存在不合理的page和die的映射，也会对性能造成影响。</p><p>具体而言，考虑盘内的初始情况如下图所示：文件A需要覆盖写A1，文件B需要追加写B3。如果按照循环的方式分配die，将会产生图中(c)所示的分布。这种情况下，读取文件A时，A0和A1会发生die级冲突；读取文件B时，B1和B3也会发生die级冲突。</p><p>然而，如果情况稍有改变，比如文件A依次覆盖写A1、A2、A3，然后文件B追加写B3，那么尽管文件B仍然存在碎片化，但B3将位于die3上。这样一来，在读取时就可以充分利用并行度，从而减少性能下降的影响。</p><p><img src="image-20240317165134398.png" /></p><ul><li><p><strong>问题解决思路：</strong> 合理控制page-to-die映射，减少die级冲突，是减少文件碎片化对性能的影响的关键。</p></li><li><p><strong>提出方案：</strong></p></li></ul><ol type="1"><li>修改内核以识别文件写操作中的覆盖写和追加写。<ul><li>对于追加写，除写入命令外，主机提供紧邻正在写入的文件块之前的文件块的LBA。</li><li>对于覆盖写，在NVMe写入命令中添加标志指示该写入是覆盖写。</li></ul></li><li>盘内检查写入命令是追加写还是覆盖写。<ul><li>对追加写，将写入数据放置到紧邻当前写入块的之前写入块的下一个Die上。</li><li>对覆盖写，将数据写入到其旧数据所在的Die上。</li></ul></li></ol><p><img src="image-20240317165149264.png" /></p><ul><li><strong>可能问题及解决：</strong><ul><li>重复小覆盖写可能导致芯片级写入冲突，但这些通常在主机内存中被合并。</li><li>覆盖写方式可能快速耗尽某些芯片上的空闲页面，造成磨损不均衡。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSD</tag>
      
      <tag>Fragmentation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资料分析(2)</title>
    <link href="/2024/03/16/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90-2/"/>
    <url>/2024/03/16/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90-2/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7bbdca5f7c717e118d880dd891f26c482ac563e239ea2fb3011abdf610f10c44">b12d8f1099daf9b6679b5d2a86d01a93e84953f82fb1ca6a3f66f8167aa7fde62eda3965debf8b48d2fbbb29eab36d22bb4905159103478fbf969828e9e9e1ef46d25d5777f24c625da9d8208e22b5bd08c9339dc11dc0daa6871a3d92d04f3e58983f308de4e7d266213d87292007016ff9cffbd71f682fa9be09830b80aeaebb7e8113f495d91bad904b674c3ae2ec87c626e34b5830aba9da3d3d9bfa80bd361a93f599beec26aa65da7246ea9dcfdd6d26c363c8bdf60fac5416736da6c707cdc63f138eb1f5741b9fc1dec643a047f8f955eec69e7d269232c48d0848414367c5e181910bd33855de1bbe357f6ab9261607b1ee6e1c618aac46ec3701c5d5026b0d43aca9df4a6f82e853fd6892a266a922bcda6ba1852f2d77ffacd0b9114e23ec96e15dde236e42e4daab2204194c78b6a18eba36e6b745ea95c862f4220218e0d845b709e8e043d01c49be939703d613737a7ab40bbfd8b3eff82fc2339f4dc95be892f87e31bebe1b69f4670c705d2aa21123f05dab7bc741996466c1dac9b21fbf1244678a7535f08064b6021d39132f24196615760582169e6318a83baf8d2e892b1ec1e1c4a49a1bdb55b5817dc9d87eeeef18b5b564c6e6fbddd03d41138276c68dbb2f08994df293e72656e4ddfb69ffb2ffcf51b91716433d9ff684175953e0d3f275a72591f242966288304ad113e2edabde1ea2b2c0980bcbcab6a0c91ffa028bb9a3a1c497b42cb88e930e8e32d7b6cb6cc95782c20773a05e4538e1ab1ab17926de8aef8acd32a4ba6ba5c8f051cbc3b6b56429a09efb08e09ba038a82b6598ff503e376bba7a818d267b0c347f89e9335b10eaf9d7826fc6cb34427ec4fca1b0149b734353d3e104f4877179cec43141bcbf70a97e6c7bdc10f6942465dd599d4c2c7e0bfab5163519cef4dde83b291614e79176ac3113c51078db38ef186cecb3e48857958746ae053987e8f2788513bd674f1ad4c49b5ff1b7cd5a3cdedd29b09d6bbe4d59477df7bcd47fcc96b3f0df0f0dfecdfeffbaec3c4c0bc2deb3ca43e2e9706e06c3ffa9e5af2e751bb6d5d8b1066dc84a9be0fa723fa86a55f7aacb56827779f7c96ca35375a6465cecafd233366dd14fb58dc404e562ab85bf4a83967414a7404ebff019eabc10d3aae9a03e8ac511b270717812daf681e9a4b11ac9c3338899c2d72d9f92a619eb0dd58fcf5f6836fc733d4712fe7727a41d2431f2daa1d296756c07a61812ed48e683fa2a571552b58eade95ad2deab02260dba14e6a0150ce6e91abfa8bc3746cf493225921cbb8e7b49a47594b1780f1502d659eb971592ab62d6eefa278ae36937a03b458336760d0bcda233999098d8474db284bd97dc6c95420fd831d798a65c5a0815f35bffc3cbc2b26fb1d287bbae3473a274310da460a135fefe3deaea4edc5aaad4e262a3da2d208169befd48157bda4d0f565a37a88d915aa0b69d813bc39f03b390bfb722091657f8da0133fb36b3ba5e834be01e9a42bdfb06a335134954b72ddc2d0cf61192df85752ec48b7a8fc368d9698c22c1e76f3f717d230415f66860dbc30575808dd4b84de8a8f383800498f824cbd9826a27cbb827a372f4a3f34f57b97ecd31bbe07af6e77972dd8b8530e976b1538320d60d55b6b92434ae04f96a445dd7cd102093dc4c9a4a0d58450c634b1fb85e5db67f812e344d19cde55be27e3cca68953afefda40c98d16f1551977b81c87041cb41ab3bb56118496cd3d9782fb1a738774ee404de2bd5ac9ff6296a079c44f1bfdc2d15774b6b23e4428d849fdc6257bc11eacd0e889e007b34ed66c95ca3d4ae8bae531c8612879db6e367dcee41cb2805530852a26c16c08352de2a3873bd5bcbd2a2aa41ca60970197b411a2bbc96dfb45bc237484b213719a1bc428624800394b3a1952123b3b7480182d053e01981f48e29853636422aff5a99738c7e17ea06593ecc3b3b3f70710f60be74806170fc0b77271a0c486a1c597cbb70f6cc03258b6d90ac0fce7e2c2626a184408156fda09ac09fcbe1cc9de8409844fa7a2436bb82b276ec4d38c645f060d35f761f8a22afd86c072a64798c5fcf7f00218fc1bc1e540377304107b00983399a14451aedd881b03173c82f8da1a8f8895f38bd6f55992f533b80a2864743cc813abd7bd7b2729bcf65fc9b0cfb83704be14450d24a97210764bdc9ac0025df75f0c7ef1442259bfcb91a1e315d801b3c6ba2bf102397c1e161937cb7754cd28d9eed0bd8c7802343559d04368a9b0e708e7f6d2d391c034255f954cdb5985dc2898419bd306bb7d610033b461499c25887a027473ab1d09851c501ae8dae4c02715a63de078e86d5dc98b45dd59fbce4a78ff769386e82f9c5af4d3de82e7a9995cd6bf8467591f1befb8d9b766b8c23a2aaba98bf9ba9f509ecfc3a720d50ed7f55c5b30f885b02454abf4b62b20d61755f2ba0cc9ef183fef1bdfae93d98674217c4cc4ba8e8600dcec598674477971e649a391a1b3cd9bd9fb6abf8c85434965e49d4ce7f36e768d829f830711b4e9d8d7927a92f061a9c99ecb93856c03d5554e3ca3ef2ea5fb2a15908b5e4bcd34880d68ba18bb58739b52c03b2beee3f6ddec642b8dfa518814bbf6a145b1f58d8c746bdc8665dbd35ee620358485664f604b4c0142728aef8673d98e93dfe0ddd7d2d015b4f4a8b3c2348e1fe7ddbf2678c02af7732b7cfc36daf0f5eabe99785de9cdc73cb5ac678034ccfa04927516a184ffce42284b0eca5b002e472a6e34258697ec44170cc86a193e14983ab99d7bda0ed2b16113c51d1c51b66684ea8585b543bfbe26cd90c8b8951d90d007e1965c80959a100c78184725eb34576b32ad51626148129027c57723e2108205e08d97eb79e9d09e5e21a6607b1cac240ea63bad4e5d77aeaedfe8a264c204f51db63cb52186c4507bcac97ee3f992b0c29657a0732c93b7711057d45710ab19441f565f43a53f16a717761027d3813a38fc8fdc3224df7a580bfc0ff37a859f9d1d253a47ba87c1c5da49a0604030ee347273eca8f7d612b1724a602c1138880832dee1f9c296758ef324623218274b66b909205b8738a1252d785b6d7d3eea64a9ea8ba0df850435ca1f75b2ca22754926e9034648e868851e125907e04833a5fefc703cd3708d19ef3489a3c03cd5d65bc2e8bf9bdd9b3e73ba0b4214fcb89d0d81c4a137d76caa6ce16fb3261ff62f21aa2e32c5ce25b2279062224448f16ddb2178cc17650f4378aeb3fe56bb716ac5b7a57ea9dd539a79c6da7757eae19c72515e36b6ccccce73e92f513ddbf032afff53649bd35b61a6569a9aee8219fde5343d98f74c420d422146c6972642036094a837e1ca4982df1b0655060e4ee0700a740b4d979a9d320a636ba06944df8a659505afbbc916c7476392537d2192d9db63ff02116b3372c30127518fdad36f26f4caa90c61be38307fa46920ad32ac3be2bf0c9ff1fa54cfe906fab7c563be6ab4eed3b2c9cb655fccd165fbcdf432bdb507c0644ccd11be94191a36e85a4e99d65b11c7052c74ed305d3c4e578e14050d937bfb37c7e3139b5cc4aed18dce4d097e03dde6fb26ad3a8d5069b9df02430b351ebe94ee22968e68dac7b85dcd5afc8c0410799cb987d519dac5098406ead8cc00947c7f3e03cf4066111ad89e9b36013eca1c7736bab4fa0b96e4759d5b9fd2b219daa50b8356726436f4a208dd9d2dc14dcdeeb3759ba4d64c2ddb931f99434da727b6cff276070df75f3edfc5cb129409a516222871d9a1614d8ea49f0d1df76ae810084139a247ebe5f5913ecd1309d1d6c0386476f3718a96dd843778faf1a04a318b359126d13559ab08a7d466aed31899f4c89d2b26efc26122b65d16f81092707ce773e4abb774ccfb3472efb6792fbb40bb483bdc9d9f70ead124cbe9855c8f5aa550e3880e291b380792355c3cdb4862dbfb63952276c1e279255a3344af6ca2df9a4c9287582700e76dc32453aacd7b30a544659f1566ec52f4136614a2b8c6b846e7146ac2bc5a0c6ffb5f067536318abceb07aa31145639e7b0e95922b2c62eb0201dc5a8482c2b22d1be2aadac591be1e9ed610b5e995d01cc1a36ca31560ca41ab2d7476c555b0af8c676a567b9742344ebad3af768bc6444865b649f0578b3742047db7ca2bd0fb03f505175bb7d9d463b384c60f3450df93b5b84b864f450db10fdc0bf460cc97c4f9930647647d859bca28381bbf16ad483cfe98d25ab743914886f680133c06cc53e093c08a726c4390a70aabbf529b051770455c398de1f2f240907e346a1e1e2675bb421780259aab502b5116369a9f2eb7be576da5078fa30a703867a95c9b56fdec48a44fe1216459ab95b751ad0f2f9e9860b730afa1e29bea38a9e5c949f51924d7c0f256412f7652f69776143aa9b4e3507c916ff0e2715ef4aa44b9142bcf407aea56665a74f6f402e629c26e04c08c3d55e512f97ffd03649258e578af5eaf2dcd59f8f376401995d8aaf4f8cf05ab364f31252b34e8ac28658d154ca8a5cae8a1555578b57a6d75b380e0eb0e94130b38adadbee6fcd395e04769f16f19103826abd9fa4eb28ff43d816887213525988cee0a8b740abfcd0ec2481746c143c8f4aa6c9872f3ad96500195008ee3bee2fa2aa703454960cae78e8e35c38afb3ed4b161efb7daa42d68c0fafa17d9a5ae9ff768515dde6c193d095e65b7dff3b546ce9f2e1b331e2dd37e919182361af03413b4b3638463de3d3662c6661e431e3a2dc6d5c2c7a298401d24577a029cbfb488b8d6075ec7c869facfbf5807e5d0fe3c26dbd43dc2da629636a89e71f5a36e3bc6e5a6bec21dcaa73c70491812a015d4e4ebdb307392d9c3bc9ccd8f1a36b97b192e2148e53d38e7fcaad815eff92a2beec613d9d324b54193b50e2966ccdac9160a60e6d0ebfdd137c2e991b153fbe79d7b716cb668ba919457c79d589e580ede798c6a7d8de56fb03148dde2dd6ac862db2f9599330b1351331e2e3f1b2d498aef6c0851bbe2af1f0c23890d60490c2251c035a82fc9419ed63e46c0b39a2fb72a7e1227791d839723c9c59203e8f50ba6391f32217f5417af7f6f02f99a89db8d0c324ed8be0c5df307c4ca35b7a1e09fe91ba6922153ad0e5f3d74cd3a5f03886d308f4dc08a237c7f2a4d0918f065888c8e0059a981d41a0abcec98210b7866f79052541a292e4f054ad70ebfea44f18e6355e8a011120234cd230c83badc31099d91f17c794deab7f74c4d9003a54caa29e35f3f162fee0e3dc5205126ff08759b295f34ba5016736f010e139d9e0eb15a3c8799915eefa3cd67429dcb89fd041668ec4784c10f649e7b6ad8c61c9ef36b5ef5b9128d03955577f1303a4cf8674fff4b61d0cadde9f10591c683386e0f7ca1fc595a9da8ec545f517a4ce70afbe126e37d71cbf8cd7513ba9524d410cba101bf0b0706f071ba0d95cbfbbebf6ecbe7a0d09edcd1cdc8659a26dd46535321d80f868189301e71f655f94d65236de6b95df0577428c554f2aea18d59be46e295867a6e30f42b2b515e2c2ebf96412922d0ca30fe1acec47d4665c8ff434681598d9519b8b8ddf705cc9f3f20e47c4ab258d0c161aa8bed4574745d383f26bfd03046b129b87ce7f3e59e157234a2e0080a700bee0c29c77e0a03c7d98498938563a781e3e956bef5df2a006ee858333c5c8c365501592d115e76dda25ab964d77c929f165ee2b773ef73b4af87c17ff7b4a731420e8eefbc9a846632279149947a7c71427adafb9ff7d3465603d46fffd91172087712fa1d6821104cea96f97926a508bee8f578a4ee946dc384298df89e181f51c1d2ea22dd6ea74e4e64c971c733c972853faedc43d80d1d72204127d83ef9757f1bc8dbf9b46b7dea9c55bc2d196604f41f1fb563735dd259e2d384af6b24f58af58802badea7a7844c6cc9bff17b91e97b6452e5741d8ad2f6db105ca410d83d3e52112df62c5ec344425726838f63e8ab3cf84f86da2408a65b804038c66e15ecb9824e9e0d7a8e49ba6f01ba88b6146b2384d1ef6a53e8f16e2922b67fc380bc95337df42e33301f7b82fd0f6bd6d96dca860b4de18ed356b3eb61c397167dbb82d908add2eeed9b9ab3c7b4b11964ba9113e17af847c235623c10bd15bd55971bf6c61773161bac294511af61721451f9c203b2e3978c7606566b6d4db4a7d8c244b80a7d638f677b41869a5f4f53ab804803740d7012721a42eea4d0cb8238435890da45487a39e06a40272a1b20edfe789f36ebccbb64cb627a3482fcfd225850b3581b9be534ce06d698f37af58bcc7cec2f5c0802bec17fc3282c3c2accc0de6424be8db6b8085114d6565544277e931725e65a195b7161a3b93eb2830816036ec90d43558312f2c9a04496376e6d7b481eff6bba472a12e76e5442a4856fd891a9dca7d91747c10a9907b7becf87220aec150cb1ce9dcbab7c3abd718767ededc5069074bbb08f79e02f1f038f538454be934d714b45ff335a2e6ed1f840faab7a80f24d6f8e4c25a4e92cb44e5052aa4a7a39d63518a581135a8619c0769fe102a059bdb3b344ed1f49024d9cac0c9db1d5cc3193813abf053da307948c6a12be729e0cfaf824ecb21ebb4abb033e5556e530a3d0eb83cd78f2b26a2c406e12001f1c6a65efa2b9e223e1e794bbf14b8b2453800ef07e80e350ef098a9552aa43397d660fa9efa37f4ecdfe30c66b08e839176230bfad0645bc8f586a105a745df0060a0b02200fb223ae596adce998353ca409b3cf72c75946ee9f395e0673cbf960813132772442c2641901cf5e97567c36feae00956e5774540e123c184f8d15abb58759a4fe9358d2908afc2e5b3a0adf6e31311fbe4649c5c6d7990c6303010476d300849d21854f4102dc6038a1d5216f6dd7a9449c0fbb40cb9291422bffb4f05cf59ffe27359ef1492cd0ce63f11cccb72879a33a9de6ef771c9a8a68192ce82d83be57578bee32e1d4010b0186b28f1d574daa525089a0da0696cbe290cb3482db8d6d24b51fc196bc51cb563c6734c4d47ecec62ef9644277fed9baaf689cadfa67dfbe29f86f1d58915bd649a0be413d823dc7bb8a3d16199acacf5f49b1874a30746b4ee808a927b0de05dfb18416b4c521664e11e91e9498a6c278fa8b82c6fd56189bcdf7fe2c85a8fa447ea7e79009a518edfb788d0e7d6785d6b40ec6baffd58ffab9e0a130289f75cf576915efc7377bc80c608244f79cf832298ffeb8df729fabe5df2fd8001ad07e28cbe9e68265e1e0a7bb70eff2c9aba65ac8289447061010635bfb00431db2869c63e092c27678e87412a76fab254dc353407ae07f9c8fd1db190935a68e8e3197ef7e59b4ca0d0ad7437afc5c8a0d8802d2f9a349dec4b295c7b1aefc7666c1cbfd3e0261f43ee3359e0d2bd51acf7f083cc993109e4290b590c69e243ea14c92447a084b4b64088766847b2323cc70a51449fd44f346e6a845bdc2f6ec0752229eec1ed7459d9918f6db31b154d9a179711d97f731c2e5ec2a3288197320e2c1f1f4313cd5daccb98a1e8a031082b5762ffa791527b09d947915aefb7295d1ee556cd7888fb7679f8bd7ea978d7a919b5ddfbdcaa90435b47d22f0689c5c770e1255d3d0f261ce0fc4a949c20dfc6870049aba846022b9738f1860bccd08a195df7b9cc190970ee1c4b78202feb4422b755b1dc48404f66e177a73b775c3ade0ab2a3572b667d36fc2c792e12389fd8c3fed4bffd96ca4a5bfefc45bba4bf609c6758c5e9a3391e9e1034f854c6a049319661d195d6ad78131cd4eb5fbe81c766fe90f1a3b7655ed04ad7ca9b251438a9c5735a76e9bdb068f97e78a540f376ceaa1285791a1416123a9b122c0b9388f97e75bc10f3fa9d5261fbb8e2cd65e0864c96c8c806a557a90346721c7fade21abc70bb43c1f38315b7c6bf35ec1f3f3149c05d9f66ab34d5b775999fe6e63ae01b0b1a80e0f1fd89278786d71717e54bce7e534b3eccb949859434e56a3a42693c7136340f08b5265ff1e037304bf267e52614356d898020aec7eba6336629603707001e311b54795500e6a239cef88194287dca5f09c1d3b0e5c40bdfe28c8f3de25fd0850c25c99d380aa33bc923ea9887ce73ec5433c58ace2725133d696e2e7aab9af1f0d10111a7104fcc03783a68d4c9459e617d5d02a32dc5b5d871275d68e6c33be6957d6df851d01e5e733fd6616fd2ae642cf13fa52e8a234a6e670d68edb61fea4bee20ccbfba4d0ae6f2078c0eb59161f8a0471fce0190ebcb82a01ea34ff9b7f574b71742611dc81e8226eaaf79011d75f40c63e3d634d8a5b6d61fe440ee886ad330a8be5ec47b4c60b06e990fb161c191e2044f31811f46c0aac26aad44df9530c73a129a6641289efb385c83d2319dda1fa054c98ba02edfa6c9bd6a825f171f898ea8099bce9f9e453a1d36814c020b46c3e09e9853d04d09b177395fcfa1aed3e2a25784b2c043b259cc4ef406e88db2f0abe3164608c9105bfbb40c87970bcdf0c0b7e47ffef07fbd6ea98eec61ea63a766a5bebf7e23b77ab4af2c36d750b8a82ddc01c5bd7bf7132279ac302435d895408d9a781c696f6d03a4e47958e7f782f1adb0e05efda02ecefca6ec8757cbb63e0a130cfacfcbc32c6d4732f26fef63b1eb53cf75aeea35771a08b69223716a28a9a2d07d6068a3959564662f592c23b89948913cc833ad8d9f15f097037bd3fefda7942823bdac35a998ff206bb6d8ea58c3cc942a80ae70ae6b9849b73ccb57b117f154c11796b1d1a3cbd81fa5d4b635eabc23570f85b2ad72ad94ad9118e0b46ace9fcb45ad9ac9dd2ea60cd479bcedfb56c6ee8072bfafd467ab237cc63f73da800097b90a41e8579b5c5ad167a21b8fe0f980d6470a1ab5c054e4bd9e3f61b8e9b9f299012d24b05bc7ca80086b0c4bb3176f4304cf5266e1a0dadb6addd4b0c83a50a1e6b691bf455e760a8d94f83410450f0a264eb36215d318bd4b223795fa273db93c691b639855ab938da50d3327a096f333ae4bd133f33731613d1892a2e16f8c4ace22ae2faa25d937a3fd28d6cef570cee59e130371a02fb790f41dccf42b2535edffeae62e64fb4f14a9eee597432ad7ef28be5098602f60919555de6568cee05d6e32f756a6c018ebd3cb65d74fa0d3605e51563da1669af1bebaa3695dc43accc26c8e5b85b9d1d93dc5ecf8368aca514d3fb252169ddf7014ade08ee2b5391394acb9aeae9389f9be441cf974b702b14ee92b0f7effb4912a0493b8ad6ebd704d9958ba7b240edde17d9a87b554b56011ac5cd08b66677b2794c2ea3a7565101b6544b318c5c03b3f46254b8bc16781becd1122ecdb35e4d98bad4d2959196af77211906dd13c90f86cf48b4464b1898c672405e9429c32ed3d8f959b535c17d50f26d969b113a20e34b5bad5b7951d542e946ecce755418a2e538bafda72cf6d4b913652f0c0ed9a20aa00ed56aea633899f5da738cfa2443252cc6fed68fd5643600e1e0f3192d461e97b2a439f41e5d6ca4b5386508c11bd46a5476d87831f81744e08fb4cbe7466df83086604e5f77f43976da2dd6cfb98f1d28b8758cfa7bdde2d54b20fb4da29e8f5838dd0ccc64c228c7e17a99a827758dd544bc7d9e0291c6844af8f6604fcbff6bdbf7392222fe1fd6ee3e2a41e7db9ee16ca4b4c2d876c8b17dc2aac394fb305cc1fb2d1baf08b90622651abd9cc14ab299d9dd55a67506974efd5e8a24979ad8ae1e72c6fd9f5729c6489284314bd26d094652be6087c1fbbddcf733f899b73d8a80e01526a0ea3f32885a21b8e4ecb730fbb82319198585e6f74abcd3cd34e3b0e7c1ff4c68dfccb4b71fdac397e6c44d07f6ce7b8c67d1f1ad820af66635611b7065a435702f30200a6e6e957f3aa6cb4bd3c238ae01181cd020520913a65962f0ece28936333b765209536526a1aa82ab0d8e7a071436336217ad97e14b5ae2e57f715b3b3ac37407e0aeb6df1f64fc720d1c72af27423f8bd6b3e074c1800a9da4bd8ac3a8d0f7c9ede49295350fdbe525bdd813e78d8dcb063860c54b355f5f9cf2dcf15195180e2be9e15ccf7501af1d47b28696fcc2b65f8c48a5550b4f5daaacdaa829c7e1402c64a6ec44b39de3e8be9484f59076a4f91a2bc4cd94d35706351357bd9e5a34c4f98554b39345ae38ef3930b2c6e7fb72690e4d52ae729ed980c36a8760f7d7516e43f9aaf83fd679c0d3aeeed8c3ff378b7d02f30a99bb74ec4fc46c5e1349733ff2284564f3bf216d83e58f30bd3c06be49dc2b8acc733ae2e86e1ba534040d816ca0bdb4610a1dc5f39b7c573f0b3461417074e288f0edad836f520026ac091fdd188fbf04db7611411d8f45a54afc391cceda0e3ee59d068fae5fad08271b458d73222af1acb7548892d797ff168e356f8cc90f02f1fa290ab80204a524858576a3f85e98bfd8aa406179b28480b297dd62c835454389b1bda4a58064197ccd3c61093e9172dafbd6913043974756679e7fac4e9fc41ef12a42c58a58786ef3cd81c7dcdf4ce0d6479837ccb5043df6cb402d838f7726717bf66d75aea574ab1a6bfb011386ce8db221408d084fa8414ee3f635eafe301e7b36c7bd5995181a921809f98387ff738410765b94cbb6c54443d288f0295aaf14ab8720ba06fc7333d1d5e842c505e44b7c7443ff3e59430e6bd645c002bb5e62353b558a2fe13b2a02702fc1cc06965d9b1c0d2aefb35aff809c0c1ce9eda35115f192b89eb67de2b80f33d46a48c010261e89c6ec9530c29aee14f32016643e7a4af594c8f72c6906fee12159c3572bbb437162164f44575087856e86e900995c612062309afb5b8e3b0915dff30d6f116653eb227949a217cfd98007217095d6ccd56fe81bab8e727d1e19cce6117f28986b02759e5a72debe00436f128876b25bb0d52eb2cc4a4dd70dfc61a3ec7d224165b9187a4bf91156d0aaceda7671a3f39a95d23ea0087f86de940fb943b3b5811581b7e4eea526d14f4ab07a7ed3f15f30fa309aad9dd5ad71f485d28f345059483b9ad342f04e0ff0197a91a86ece969f9d3f03669bb1225d16cde44611faba61171d9f5267cd20e24fc7fb350eee51cfe5088177e047d6cd6b22d02ceac139bef028047f20f241c0f25e9f4c180513e5eeb95b0b1d802b9f9dc883b2035a184bc4a3fdef4f01b755ea38c0a6ba61331933a13ef63b26acb59c2ce634e78776cee778fe78087c0af1cae931356eef6f62367815e13a26bd743cd27683ffdd263df5e2a84773f08c71de234aac8674ad59cc76ee6c5f8c85ab8f8ccc5fb8a62d0cc28729a58c45bb7b5e7ee6ec553fe3e3b1c9bb3b39018ea1d111ff14b92d8a1ded02787f6e1ebfa3acdb04c6502745ec600ca0f0df19f625579a4a841109df7931e9d1bef5fd34692acfb54936f8c8d59cc748dbdc9d528bf9eba2ed55ffc60bd40f6adc5b9d117f3858369d68f04f8d5d7ea5796d13ba17b9cc6baeae58614f85c5b615cd6fdcb6e72f38cc8259c9e45347050b010523474e42baede4ead774bb32a06013e87e1d436d0a8446560aae461d1ca4b1bc6a1db283fff58dc1d59c1c00ba99f551fa06c651f0e45713c9bf1fc22818e948a225fded2a196d89c2851c4f06df0de4961a157240129d79cd9fabacce76902d083001c5b7d789f0c816261a7ca9c5e7976758aedf1ba1bf2af63e3aa8965c3538e8296e8fa3f2609e891804fa4c48b8582437e7d3d233b7cafcd12924f1ae17c9296c4ea12c0bcd6169ffeb225b15e66de4b5c51f36dae7c03d684e90dae1bdb184e4c7c181ada52a5513adef226dd112cd184e1718691ce0c6135a2dc117099eca081e66d02d0fb7db3088f5b1ee8758845caec80e90ed85a8bf2d63969176b29cfe0aa7f849b39101ab2aea6193462b85a537c730c91d1f953bf257a9fbff1c1f0cad1d7881f27cd0a64ff2109f6938813e98ca6fdb494e0878e932a8efbb921a31c8796d4d75ea1a5c16d07e5f0033319970d33573870fb62290ee94a86810c892063a035e52336324060e668071da9eaa26a9589903f6f6cc125166aa6c2e0268a16d014eb451dec5e7fedf0c71d8548741994e9f1119bd5c6831c40a268720259f6217e9b2531c8532c4953acf5d365632d5e3dae2b7ae9a8d7aeddbc36b24a1e257a9bc87a6807e5df754411a0a83b8693cd6b6464515b41e77e090b36e2737840ae41d686405393e649d6b80eee663501a6dac93412223cd684abbebbe910c0fda3a2c7a067bf20a699d9bb1b342f4d7f1e53e0c22ffa74c2682111a9a78fa99ac6599b3a6b713a091eee02cd9b565838c09bc59486e48864d92df841b51a05ffb455ce4dff40f13238df777420e4f362815151e2f47611df5787ef852f39ab1c33c862a095fefc9c7f44aeebd30bd5dc47e36a865f78e3c2dd8d14ca28b8381c71a2a8b817efc9b945ddc54e1f70f53e3867b23407ccf2ce2334af9f20948da281589bb29b25e6266da0a091c084c724708fad03c2afa4410aadcdfaf600eb4633d2c4f9b662862b51aa77dbc4c474f47cd9260d7f1bde72cda1a07b7c3bc9fdf5ae52948c4c906c1f0fb2b286cf0b407ef44ae0e103f6f7d9020c15531804ca8dc9027f06cf8ab428ca2f2a1ab7c4c2578e59917e93430b69760a0599f7eb44922dd42559d066ad996bd16e136e6a04f55f53dcd93068a70abff3c305ac753588a378bcd97698a03f27e6f98f0e048841504711d7dc6cb6816e9f7b4c207ec030bf12531d6353af7f667b7282b8f72c4b357e554a1bcc07bbded83ee143c17e96f16975414072c2314fb74e9300ace74bd9f0e974d2da69077fc5c1ef1e551f9bb948ba8e21b38ac7b0269e1a47084b5dcc88324e48ad63fe3e14ec883e35de43e17ecdd8162904dfccb2a95b18b12e0988a6e196c5b15bd4b9c0e33e070ddcae629af239d0e462cf04421825bf4c12c377d4fcd1795285f0771e188c8812c0f3311a033775f9affe97d575453c2062af2f02ca90eac8fe7abe76edb81d6feb7f377670a9061b2f89205ea5aa9a67b25b80e1ca4f0977f8697b27768f3a58b5adccf7ecca878a8b71ca0c1923da83be93260f9edd67b66f5769e93715426995fe2620883e133cda84826c32cb380a756bb1163617d3a312b10fc521d8a2862342765ef4144d5aeadb01fa40731849a1e8a389787de6553511c7aa27dc38</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>行测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>private</tag>
      
      <tag>增长率</tag>
      
      <tag>增长量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资料分析(1)</title>
    <link href="/2024/03/16/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90-1/"/>
    <url>/2024/03/16/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90-1/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="53de34b1999355fe180af5799ebf8400f0dd2c87428124d4d710d3d8c01cd4a3">b12d8f1099daf9b6679b5d2a86d01a93c69c58669c1c5d65be982c9069c523c2ed5d8302b837614211566db3bae24de41f149f3259ea7b487e782f81bba10bcc6e2c81f6dabadd98086071ec79be68553da824d20e9e1968a9781b5f6f052c85db6961bffd42e46efe091b18255c6cbcc3a2bc2ad6c125d3dc6eb6ead4d548e76d1e06e877ed3ae086e01a52acd9dc43bdc79fdce722a13f40751f537adfc9331101ffc140a80fb6eef7f57844229ede546b4a8801aa7ef98e83c0de200459eb29978c2ea6b56b5547d1deb1c037f82603e2c1ff8766fda0bf4cc02115d096915d57fe11bc7c5e0dd9b82ddda2380b19ec8da3a35a233ec8ec7e1b4d060b71f3042096804572452b9fca1e8f295626b865ffb89188567e9214a90589ff1bcc361123f42e0881a0975da207bbd8743ff585e47a2c18d6956afd38eb6539ccac5e334a533cdb56619bc9ce70ceb4b807853846f77383822d4d0235771e5c89d4cf201f1919b44d3434bd0ddb76bf40e60d66e29482fe0bca904f2cbe8acfdccfb671e43b4338fb18389c7c79be72fb3df5e72ee4c7e65faba9906278c28323ff1cbb1b0cb21174290b7c5bb56dbe72ac2b3fb42ae2cd38c44387adff431c00b354958b54b6741f33c98c4d46f8dfebf7f57fee877d681eaf55c5fc8fe3b7b18b0ea70eab15315df14d5a04d2e833aeb8ddd913814dd5f5c347695da95fafcd96a35aab363b438dcb8e86a96afde8687ba1e32760f2e3f9ceb364e0dab5c15722bbccdc5d7646ae8da18358d9ef195a8fa1cf415f1596fa4d65cab3e6a2122ec907345e873c68bdb325103a4b51011f1fecff6a8bb2e7b1b55b3b14233e0728fdbe7736f21f8f58be056781ac667dfcdd0ba9c78f0305b62d5240761c35062e31d9af27f41707f1827c15e899df7d7ba0c42bdeecf4b38c2d50fdd052647f2ba5a79d085e6ff877c31503800f91594b70b569e9e888daad100cd91abbdbca4366e57500599b86951ae705bc63c31f80dedd485025cfb9961cf0252127b378ae168b5df04493d80d6697c83c6e66e5905a4146bfef7891db701f2e384d663c6c06baf1ec5eb276ac4d70f9d2672c9a840357873bfc9e9a541559f578e60f779b708740f5b4ba1f2fdb2eeaf87ea67e0a9c24355075f6c51a82aac19c2787213164aa555842eac39fea6e352bd9a31ff1efc535ce79621facb060b18c9e47e074f41981d57afd415113b8ffc50d9deb4c1d47d1cb31137dc4695ea272ad4818509a2005b2cbd94607e2acac251bcd266f2bbf09399f906a512d9340d75d7046d42a80cd1399a3bfe8d4f2c64ce49dcfbac98f321851b21b89c5ea950eb8ff6fa4c5ee581a3d80054ff126912344651d9c1a328edec659232836083f6683db7018d1cd1ed6d6279af06ff55316c5710c4f0863aed2dbc37f3e29004ec3245da34b2dcd7c55e53a29060e809ebea1f879694233a3e8f58ae1eb455efd8e0672751c2bdfe38ed4bd89b003b5eabc7fd9dd6ce303b40bb38da8ea20d3cb70d4acca5f385434f0726bd8ac447d4c94c57d29e1782768539941e00c1b039c45ca5ead3a3818150abce87b38674ad4a0641b93939d29b9fa3d35ccd2b63e28c86c923086d0044b543c586873189ae6253f56d6c612d149f4058d89816dad891e64ba7b1c3150c93d72f3819a5e6e1674dc523114f07cd1bb3a05a49ee2cc75bec2f25f0e5a941326f3ccaef575d2a37678304f02147e46f9cd60bcdcc8b119bad066d5d480d4bbc93fa3592a7ec0a6798b6ab4769315bd4ffb41c78152631199ac6dace64c3e9aeec41a44ef3d9bb5c28dc07115033001597c599130a12a1c720157a067ca4ef78b59d32495bc946361bae08db1ffbc99a97e25002742dd157f51c3837e37c3b65150de3e603adcb7b0abf1c20cd894d6dac594864fa43c2fd9d1b4ff85a7bc7c838ff8a33e43207032e34f11bc7797000bc790d075a58bcdcb46248edaa40635734658613e2b1fdaa93092299f8826d38eadb66569fc56255b802a43a8b8fc654c32f22d81928b119604c4a511ac65b542ff4b776681249fec739fb5b26328e9745cdac7a37a086694d95e99af2179119541cc150b79c4d4a6f541cefe29066c082499d64f4ba0b4dde927bcb286346abca4a010d20ef71b54c32605f5d764b6ef011f3a73640f5fb5572e391447863986a50edad8423022ac10c17de5b4502974fb81253d731713e87c31b2db38c1668a59693b526e8e07a1a5eee420b9f38ac78111442e7df5f7a5f21bf55f92ff703f8f090a3f42493c198566bcaccf0784cae368d6f1d8b36acafe6683b919dd12042c0f99abab0bd203f1988b8c1f41ca1f5333f80229f6d11f58c7c39218b4e666bb6d73a59c4bf54b2e8092e745fbd00ab1694ed9e0278189c91c3a068f6d2af311b9bb9c35df54f6e5a78b3a382c2f12a64570615572b61145b6ba6df2977a29b85435f04d8b674d7d01f740b8370ea63301971656a0b1d884a60c515c83248b003815e9a03f553a19d7b05a4254fb566324f968285bb8b5bfcf89807bf95339baa53f8f081dafe7f0df2f3e234d0bf95cdfa2145afeeda66b92561006469228ff98b9b317a3b34e0b962d290bd9aa5c0f155e4b23cdc818a7633f19ade00a21259954adae3438515416e43e7e0bd75d2846e2c0f4d908bca5925ab5fc902c3b7781b3cc5ca653f578dc49b64f732d1f96c4324a7ad0de3610b771f4ecbd5e30ae0a822921f5a46172e0c2e4a4a18cc3d6f647f9ef84ba491992373fa80f51b2172bb4bf87e3c11912701f4d54dafc024267ef7b38f8f8e5095b2221ff884d0b45fd5eac49fddfd8e8f32bcae33008a3fc7513219e4178961dac9942081dc53335f5d1b0ad3f3082da0ccedef8c1992b65e6ca297841cb67b0108f0b0a27327dec7be1155705b80405df87feb70f57af312adad858e64e4ecde2d0e35214ff3ec12688777990657c8f0de2c2dfe44db56922592cdbe0d9dfeab5ce57d841598ffaa8d951e540dc358c1f860ae746d108a5301e70e3d3156959dc0458072ed9c00941dd06f4200bfc7f76b7cf99888380f509e52356f0861574204e0083ceb866befded8919ebc7c3bf7244a789a45b6ca6cc756a785b30b6cf7a644ac2d098c21186a9f6eb58dd442e1c322bcb8361a1991a121cc1ad38a301d05a957aeb9f75d29d6f36bacf810cb87b293bbdb7007364ee8455ed9c9a5b80eb1824116b7fe699b8a3b749c21a5b30f89d10b134ff370a25db25b02e5e9f18bcea9cf36ddac59ec3c95e7e89de43b6a659f73d1e7c66f68ef27c0a14971ba053b1c30e3e492f7960c35ed7a4ed897e39e72a44e1e81b2c00008bf269d588bee931ce246d9ff9529c4ac51a18885e74e0f7161243390b39f4bc283519a1c1b0660b41ddb9b2808d99fc5af476531400551c2b7fe63eb9fab9e1264f541d6952af8445b1f1b27a48f20da7fd4398f26a71a15a9bc83b13103b9c62ff547fae8a709db7fc240c4cabec371f94c1a5ce3157b8fa72c26f3f41f17c691f21bc14b2b19678ed50ff848b3ce24e16ccb7c957bfbe3188fec68eb6e298c29deab2be78f180506c6587ced512b7d42b10ddaf2398ee60100cdf91674cf59ff29216987e4f2408e53988b9f57173af4095d44da52082ce5b940a4600d749bcecaf6cc29deed88f91e0b72f19e127fa48d7a044e69bf393bca9a39687f4f758ef47450ddc07706a385359bfc335d0cae10e7520ab951249e10bb7efb848b3f4242ba3805db78b51ebfab6922614141743f003cc2914e57480b687e97ba75c510d92189f2e748d4b7c43a73c9f76e4c2cb3fae3d1de0dd2aa15aca7259888db15a36dd450cc08d82f24c54c31b88f28342dc70904e48df7b5e23c80621dcc2aa405eaf9879212710cc0bfb0a76962292caa74948acfda01f5b6532f696a7306e2f0d92966e54dd25ca541eef0f3c6d624312b51367d5a8ec2502844a5fa312ca5fced3759322a530138d0eb291cbc508e99e630241ff49a5f53ae3c33328c8dc044408f790e85361e7bec01f4c599c7093a2713e7bb647ee809b67a3cc942bec33d57b72fba52e96a072c9269822a39af0d0c1d7f65b5642102835cd258b70f8882c0d9b9fec04ecda874e93b7896bfc66210b0ba45bcc0bf86b6f01600c981444d043857395c0214b4be24e2789a2c8deb2eec31d08def8762c869967c57fd04843e9890d20e925403b8b5a73582d7c8f0be3e9d2de87de8b6b2a1e8cedb77e5babeb50e2c7cbe08218b614bc0c0c46c73ab15dafdbf6f305a038be94a394f8b3c85dab1d0817be1f286f035902d8d8c402c34c8f91eeba378c76caa89459cdbcbd75bf80570e341f52e90d8097f9fb22781b2a1aadb604f72960643d3d98f70048b9f1b03caba19a22286e839618077977a02ea3795987e32cbd620889cad2f50a1952e951957e6ba8fcdfa404530c925d9b592427bb6be7323bae2ac18ef9888269a6c3a5fd3ff9894c72bae661b65517e45a9571aba8f260dd1b2be4045da2806905b8e57d37dd17cfc3e39567808a567a19f163b71c9ffc24d6052abd898047e48a5c4da33b8b302dbc4834454c15722206cb6998c2ce9feb202b05c9d300f40745ef86c52822d0c6a9825286284feac0bc14a3b012a4b362549b8bcd0799fe115cfec9e1ac2b62ea9ac1dfd2ae0b0e12c211dc720bb10fc708373aa7c4d6126df5c4e062dfb2b1fb79ab2d3cf4375e4449e712c1fd030baa9a53df95418737f7fca3d78615199b5b0f5d32fdf52c492a3ab305a029a92fea55da8af4e03d5203b0d6ffefc61f1b25de3433a0f325c9f899c3046b46cf2de3f03767af1008cb06ee720512a64f03d0dd3d43cf1c7006f8ae42b4c88691583fa85cc10d2cd69dc8153c177f8a604efbca073581cb88027e7e252652a4c3c5ecf8d13ba3d3c3fd8dd41e7d73b916e33bb6ad6f53b5ed3188f04a4b5a18c52351105cc6adf1fd911e56f08e72adf65218f75f1642713952ee065ae1a531c974255b28c298ea3c4c037fbe49103f32d25f07cd69e82da32c591fda7dd3099ad7526840096045bda154bcbe5a0e67082081528b37430a649b2deaf429b3f5bea2c8bcc38dc22ed71e42a0766db9166c4eaeec064968c769bb27aa99fb179fc9b587c9a3ff2024d83144021970f404e16396f68bfea5027b00a6374e67096ca592188a7a5d8b3d074982262cf3a2154c86749aee6fb31f4a8f22961546d359a9801a215be8af61618e436c4e693e9d383d2eb55948c523a5605f0d80ebe482b80e5bde9039fdabcd26b7f25feec365b3f57e10da3e324a1ff44f6e43db066b4273bdd44b538533f6d0465f65beffe5438f5553a2f31d1b964f31724d7b86b892faa4222a06a98edf404861ddd16034404806dcf503dbbd5a951a51b981a4c8a087e978bfadd5f917cb1555940aec99322c5cfadaac16c44bf150cb50464ded977cb0eed29028352eb11db5b6b16973754d1c7c20bb3b8631f46f37c4c50f682879ebe4d1ca1e0aee4facbd88404ed529c558694bb08371f5de509cc940d784fa5ed300b443e55687f40e2f81b15173b149bfb8c985b049983027ad900f272d762d70ca867df873f775fc633d7ebcc46e8b5152a1ed0ceb58bf962f069957a589698eecb9acb3dbc3ef128997ec006091c254385a752b8604f3b287c64a14a2d96dd42d7a3bdf7f8bc2ccca938e7e24467589eef5934a891617b6be522c733d8760f25dbb3fb9cb7a716a81922a3665f0258fb055d85075534b62a2933fe37830164f09d0b4499a19701bf10a53fdd7ef30eed731d3c40476d4e50feae199c56ac68d2d07840767af4934fc5a64b5566449a1bbf04049f72598d8863dc6e08be31fef50b44dbee4f0388cf484167d036b750f3f27bbbe8e801cb68fc5266e43261c0250ba9872da72d8c185e4165ab35919be42bcaae6106bcf36144f158a51d372024ff9eb71b6aee11e968fb9257de1cf788880cd79e5aeb97c150a3f96a1c2fdcd2e78a9b62f197b6c2ffa92d7e29e29a4de8baa835a5e0ef1b782221340f3a09be6d20273e140e9b28afe30d9d5bcb9c946b7cc15e4bd0adb361431ac2781d17f2038b1e15b7155345513cd3e287ecda0a82f245f1258ac93997cac18a8b7da328866b6f72c2d85f184188c2ee6032c27e13a771b0c976467058e2ce458b855d0b49a8db93b6ec40583d127f35bc4fbf60b23906c13d292e46cee4febecbfa15592803ffa0ae906229989241c81b608e89c913a6ce15e8a4d4b9c6dd093454f4e53de0900bdc3d3f89100d70240877d9665e86bbbb19a1b4dc8518eea01c82a0d5ea801f2d0e051675b7dfe3c00197e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>行测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>private</tag>
      
      <tag>截位直除</tag>
      
      <tag>分数比较</tag>
      
      <tag>基期</tag>
      
      <tag>现期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Excessive SSD-Internal Parallelism Considered Harmful</title>
    <link href="/2024/03/14/Excessive-SSD-Internal-Parallelism-Considered-Harmful/"/>
    <url>/2024/03/14/Excessive-SSD-Internal-Parallelism-Considered-Harmful/</url>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>随着过去十年内固态硬盘（SSD）容量的显著提升，SSD管理的基本单位也随之增大，旨在减轻管理负担。随着每个存储块包含的页面数和每个芯片的块数的增加，固态硬盘的闪存转换层（FTL）需要追踪更多的信息。因此，现代SSD倾向于在超级块（一个包含多个块的更大单位）级别处理写入请求，通过在所有可用通道和芯片上进行数据条带化来增强并行性并降低动态随机存取内存（DRAM）的使用。此外，SSD在超级块级别执行垃圾回收（GC），选择一个超级块作为回收目标，迁移其中的有效数据，并清除整个超级块。但是，更大的管理单位以牺牲性能为代价来换取更低的空间开销。</p><p>较大的超级块意味着可供垃圾回收的候选超级块数量减少，导致必须整个清除超级块，即使其内部的有效数据分布不均。考虑到实际工作负载很少完全均匀，这种设计在GC过程中需要迁移更多的有效数据，降低性能并减少SSD寿命。因此，更小的超级块对于提高GC效率至关重要，是优化SSD性能和延长其寿命的关键。</p><ul><li>实验：<ul><li>同时运行四个 FIO 线程，将不同特征的数据写入具有不同内部并行度的 SSD：完全并行将数据条带化到所有通道和芯片上，1/2 并行将数据条带化到所有通道，但每个通道仅使用 1/2 的芯片、 1/4 只使用 1/4 的芯片、1/8 只使用 1/8 的芯片，实验结果如下图所示：</li></ul></li></ul><p><img src="motivation.png" /></p><ul><li>结论<ul><li>随着并行度的增加，盘内写放大程度也随之增加。</li><li>随着并行度的增加，IOPS先增加，后减少<ul><li>这是因为高并行度带来的写放大导致了更多的垃圾回收，降低了性能。</li></ul></li></ul></li></ul><h2 id="方法概述">方法概述</h2><h3 id="灵活的超级块大小设计">灵活的超级块大小设计</h3><ul><li><strong>思想</strong>：大型、顺序的请求使用大超级块，而小型、随机的请求则使用小超级块。</li><li><strong>实现方式</strong>：<ul><li>大超级块覆盖全部通道及其上的所有芯片（# channel * # chips）。</li><li>小超级块覆盖全部通道，但只使用部分芯片（# channel * 1/4 # chips）。</li><li>通过分析请求的起始和终止扇区来确定请求的大小。</li><li>在执行GC时，优先选择无效页比例最高的超级块。</li></ul></li></ul><h3 id="生命周期预测">生命周期预测</h3><ul><li><strong>粒度</strong>：逻辑地址空间被分成多个块，每个块由32个页面组成。为每个块使用4字节的数据结构来记录其信息，包括加权平均寿命、上一次写入操作的时间和类型。当一个块被覆盖写或变为无效时，更新该块的加权寿命。更新方式如下图所示：</li></ul><p><img src="image-20240314164256958.png" /></p><ul><li><strong>策略</strong>：同时开放多个超级块以服务不同寿命的数据请求，例如，短生命周期超级块处理寿命小于1秒的数据，而长生命周期超级块处理寿命在3到7秒之间的数据。对于还没有预测寿命的数据，使用默认超级块。</li></ul><p><img src="image-20240314164303987.png" /></p><h2 id="实验设计">实验设计</h2><ul><li><strong>平台</strong>：FEMU，参数设置如图所示。</li></ul><p><img src="image-20240314164311173.png" /></p><ul><li><strong>负载类型</strong>：<ul><li><strong>FIO</strong>：使用4个线程，每个线程向不同大小的文件发送总共256GB的读写请求（读写比为50/50）。所有请求均为随机访问，请求大小固定为4KB，队列深度设置为32。</li><li><strong>TPC-C</strong>：使用MySQL数据库，页面大小为4KB，通过BenchBase工具执行，配置30个终端和30个仓库进行测试。</li><li><strong>YCSB</strong>：插入了1亿个键值对，随后使用工作负载A（读写比为50/50）发出5000万个请求进行性能测试。</li><li><strong>Fileserver</strong>：使用Filebench工具模拟文件服务器的工作负荷，创建1百万个大小为128KB的文件，并通过16个并发线程执行模拟的文件操作。</li><li><strong>GCC</strong>：模拟了编译Linux内核的过程，重复执行100次。每次实验都会将内核源码复制到SSD上，然后编译内核，最后删除源码和生成的二进制文件，以模拟编译过程中的磁盘I/O活动。</li></ul></li><li><strong>对比方案</strong>：<ul><li><strong>Baseline</strong>：传统固态盘</li><li><strong>Partial GC</strong>：在使用超级块的同时，将GC的单位设为单个块</li><li><strong>Multi-stream</strong></li><li><strong>Autostream</strong></li><li><strong>PLAN-NoPred</strong>：在不进行生命周期预测的情况下，将大型请求写入大超级块，小型请求写入并行度较低的小超级块（1/4或1/8的芯片数）。</li><li><strong>PLAN-Pred</strong>：在PLAN-NoPred的基础上加入了寿命预测技术，根据数据的预测寿命将其分配到不同的超级块中，既有1/4也有1/8的芯片数版本。</li></ul></li></ul><h2 id="测试结果">测试结果</h2><ul><li>写放大</li></ul><p><img src="image-20240314164319711.png" /></p><ul><li>GC效率优化</li></ul><p><img src="image-20240314164331949.png" /></p><ul><li>吞吐量优化</li></ul><p><img src="image-20240314164338783.png" /></p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSD</tag>
      
      <tag>Parallelism</tag>
      
      <tag>Superblock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPDK NVMe API</title>
    <link href="/2024/03/10/SPDK-NVMe-API/"/>
    <url>/2024/03/10/SPDK-NVMe-API/</url>
    
    <content type="html"><![CDATA[<h2 id="spdk概述">SPDK概述</h2><p>SPDK是一个专为高性能存储设备开发的开源C库，它提供了一套高效的API和工具，用于直接访问诸如NVMe SSD等存储设备。SPDK通过在用户空间运行，避免了传统存储访问中的内核空间切换开销，从而实现低延迟和高吞吐量。</p><h2 id="环境库-env">环境库 (env)</h2><p>SPDK依赖名为<code>env</code>的环境库来处理内存分配和PCI设备操作。在使用NVMe驱动之前，需要初始化<code>env</code>环境。</p><ul><li><strong>内存分配</strong>: <code>env</code>库提供了高效的内存分配机制，例如利用大页面（Hugepages）来减少TLB (Translation Lookaside Buffer) 缺失，从而提升访问效率。</li><li><strong>PCI 设备操作</strong>: 提供了发现、访问、管理PCI设备的方法，包括枚举、资源分配、直接内存访问（DMA）配置等。</li></ul><h3 id="初始化env环境">初始化env环境</h3><p>以下是初始化SPDK环境并枚举NVMe设备的基本流程示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdk/stdinc.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdk/env.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdk/nvme.h&quot;</span></span><br><br><span class="hljs-comment">// NVMe设备发现时的回调函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">probe_cb</span><span class="hljs-params">(<span class="hljs-type">void</span> *cb_ctx, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> spdk_nvme_transport_id *trid, <span class="hljs-keyword">struct</span> spdk_nvme_ctrlr_opts *opts)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;发现NVMe设备：%s\n&quot;</span>, trid-&gt;traddr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 继续处理该设备</span><br>&#125;<br><br><span class="hljs-comment">// NVMe设备成功连接后的回调函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">attach_cb</span><span class="hljs-params">(<span class="hljs-type">void</span> *cb_ctx, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> spdk_nvme_transport_id *trid, <span class="hljs-keyword">struct</span> spdk_nvme_ctrlr *ctrlr, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> spdk_nvme_ctrlr_opts *opts)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;已连接NVMe设备：%s\n&quot;</span>, spdk_nvme_ctrlr_get_serial_number(ctrlr));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spdk_env_opts</span> <span class="hljs-title">opts</span>;</span><br><br>    spdk_env_opts_init(&amp;opts);<br>    opts.name = <span class="hljs-string">&quot;hello_nvme&quot;</span>;<br>    <span class="hljs-keyword">if</span> (spdk_env_init(&amp;opts) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;无法初始化SPDK环境\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (spdk_nvme_probe(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, probe_cb, attach_cb, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;NVMe设备枚举失败\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 业务逻辑代码</span><br><br>    spdk_env_fini(); <span class="hljs-comment">// 清理资源</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>probe_cb</code>函数说明：<ul><li>此回调函数用于检测每个NVMe控制器。返回<code>true</code>表示选择该控制器加入SPDK管理。</li><li>可以根据控制器的PCIe地址或其他属性决定是否管理该设备。</li></ul></li><li><code>attach_cb</code>函数说明：<ul><li>当<code>probe_cb</code>返回<code>true</code>时，会触发此回调函数，表示设备已被SPDK接管。</li><li><code>ctrlr</code>参数代表NVMe控制器，可用于进一步的设备管理和操作。</li><li>常见用途包括将控制器和命名空间信息存储于全局结构中，以便于应用程序中的管理和访问。</li></ul></li></ul><h2 id="数据读写流程">数据读写流程</h2><p>在完成环境初始化和NVMe设备绑定之后，可以开始进行数据读写操作。这个过程主要涉及以下几个关键步骤：</p><h3 id="分配io队列">1. 分配I/O队列</h3><p>每个NVMe控制器支持多个I/O队列对。在进行数据传输之前，需要为应用程序至少创建一个队列对，包含一个提交队列和一个完成队列，用于命令的发送和响应的接收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spdk_nvme_qpair</span> *<span class="hljs-title">qpair</span> =</span> spdk_nvme_ctrlr_alloc_io_qpair(ctrlr, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (qpair == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;创建I/O队列对失败\n&quot;</span>);<br>    <span class="hljs-comment">// 错误处理</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分配空间">2. 分配空间</h3><p>使用<code>spdk_zmalloc</code>或<code>spdk_nvme_ctrlr_map_cmb</code>等API分配DMA内存，以存储从主机到设备以及从设备到主机的数据。</p><h3 id="执行读写操作">3. 执行读写操作</h3><p>控制器和I/O队列对准备就绪后，通过<code>spdk_nvme_ns_cmd_read</code>和<code>spdk_nvme_ns_cmd_write</code>函数执行数据读写。这些操作是异步的，需要指定回调函数来处理完成通知。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 写入完成和读取完成的回调函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_complete</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> spdk_nvme_cpl *completion)</span> &#123;<br>    <span class="hljs-type">int</span> *finish = arg;<br>    <span class="hljs-keyword">if</span> (spdk_nvme_cpl_is_error(completion)) &#123;<br>        <span class="hljs-comment">// 错误处理代码</span><br>    &#125;<br>    finish = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 其他逻辑</span><br>&#125;<br><br><span class="hljs-comment">// 示例：向NVMe设备写入数据</span><br><span class="hljs-type">int</span> rc = spdk_nvme_ns_cmd_write(ns, qpair, buffer, lba, <span class="hljs-comment">// LBA起始地址</span><br>                                num_blocks, <span class="hljs-comment">// 要写入的块数</span><br>                                write_complete, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 回调函数和参数</span><br><span class="hljs-keyword">if</span> (rc != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;写入命令提交失败\n&quot;</span>);<br>    <span class="hljs-comment">// 处理错误</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="轮询完成队列">4. 轮询完成队列</h3><p>由于NVMe操作是异步进行的，需要在应用的主循环中轮询I/O队列对，以处理完成的命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (!finish) &#123;<br>    spdk_nvme_qpair_process_completions(qpair, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 进行其他应用逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="资源清理">5. 资源清理</h3><p>应用程序结束时，及时释放分配的资源，包括I/O队列对、控制器资源，以及SPDK环境，以避免资源泄露。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">spdk_nvme_ctrlr_free_io_qpair(qpair);<br><span class="hljs-comment">// 执行其他清理操作...</span><br>spdk_env_fini();<br></code></pre></td></tr></table></figure><h2 id="示例">示例</h2><p>一个完整的读写流程示例：<a href="https://github.com/spdk/spdk/blob/master/examples/nvme/hello_world/hello_world.c">hello_world.c</a></p>]]></content>
    
    
    <categories>
      
      <category>SPDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SPDK</tag>
      
      <tag>NVMe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用FIO测试SPDK性能</title>
    <link href="/2024/03/04/%E4%BD%BF%E7%94%A8FIO%E6%B5%8B%E8%AF%95SPDK%E6%80%A7%E8%83%BD/"/>
    <url>/2024/03/04/%E4%BD%BF%E7%94%A8FIO%E6%B5%8B%E8%AF%95SPDK%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="前提">前提</h2><p>若在 FEMU 上进行测试，需调整 FEMU 以解决 NVMe 协议的 Admin 命令未实现的问题。以下方法仅为暂时屏蔽该问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">--- a/hw/femu/nvme-admin.c<br>+++ b/hw/femu/nvme-admin.c<br>@@ <span class="hljs-number">-999</span>,<span class="hljs-number">6</span> +<span class="hljs-number">999</span>,<span class="hljs-number">8</span> @@ <span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span> <span class="hljs-title function_">nvme_admin_cmd</span><span class="hljs-params">(FemuCtrl *n, NvmeCmd *cmd, NvmeCqe *cqe)</span><br> <span class="hljs-keyword">case</span> NVME_ADM_CMD_SET_DB_MEMORY:<br>   <span class="hljs-title function_">femu_debug</span><span class="hljs-params">(<span class="hljs-string">&quot;admin cmd,set_db_memory\n&quot;</span>)</span>;<br>   <span class="hljs-keyword">return</span> nvme_set_db_memory(n, cmd);<br>+    <span class="hljs-keyword">case</span> NVME_ADM_CMD_ASYNC_EV_REQ:<br>+        <span class="hljs-keyword">return</span> NVME_SUCCESS;<br>     <span class="hljs-keyword">case</span> NVME_ADM_CMD_ACTIVATE_FW:<br>     <span class="hljs-keyword">case</span> NVME_ADM_CMD_DOWNLOAD_FW:<br>     <span class="hljs-keyword">case</span> NVME_ADM_CMD_SECURITY_SEND:<br></code></pre></td></tr></table></figure><h2 id="一编译fio">一、编译FIO</h2><ol type="1"><li>克隆FIO源代码库：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/axboe/fio<br>cd fio<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>编译并安装FIO：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br>make install<br></code></pre></td></tr></table></figure><h2 id="二编译spdk">二、编译SPDK</h2><ol type="1"><li>克隆SPDK源代码库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/spdk/spdk<br>cd spdk<br>git submodule update --init<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>启用FIO插件，运行SPDK配置脚本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure --with-fio=/path/to/fio/repo # 示例路径：/user/ctz/fio<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>安装依赖并编译SPDK：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./scripts/pkgdep.sh<br>make<br></code></pre></td></tr></table></figure><p>编译完成后，在 <code>&lt;spdk_repo&gt;/build/fio</code> 目录下会生成 <code>fio_plugin</code> 的可执行文件：<code>spdk_bdev</code> 和 <code>spdk_nvme</code>。</p><p>在 SPDK 用户态模式下，SPDK 将设备从内核驱动中解绑并绑定到 SPDK 提供的用户层驱动上，因此解绑后用户无法通过 <code>lsblk</code> 等指令直接查看设备。为了方便使用 FIO 测试设备性能，SPDK 推出了 FIO 插件。</p><p>SPDK 提供两种形式的 fio_plugin：</p><ul><li><code>spdk_nvme</code>：基于裸盘 NVMe 的 fio_plugin，通过 SPDK 用户态驱动直接访问裸盘，用于测试裸盘性能。</li><li><code>spdk_bdev</code>：基于 bdev 的 fio_plugin，通过 SPDK 块设备 bdev 层进行 I/O 测试，用于测试 SPDK bdev 的性能。</li></ul><h2 id="三从内核解绑设备">三、从内核解绑设备</h2><p>使用 SPDK 提供的 <code>setup.sh</code> 脚本，将存储设备从内核驱动中解绑并分配大页：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /path/to/spdk<br>sudo ./scripts/setup.sh<br></code></pre></td></tr></table></figure><p>创建 JSON 配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo scripts/gen_nvme.sh --json-with-subsystems &gt; /tmp/bdev.json<br></code></pre></td></tr></table></figure><p>JSON 配置文件示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;subsystems&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;subsystem&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bdev&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;config&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;method&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bdev_nvme_attach_controller&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;trtype&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PCIe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Nvme0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;traddr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0000:00:05.0&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="四准备fio配置文件">四、准备FIO配置文件</h2><p>FIO 配置文件与普通配置文件大致相似，但为了使用 SPDK 编译生成的插件，需要设置 <code>ioengine</code> 和 <code>spdk_json_conf</code>。</p><p><code>ioengine</code> 需指定编译好的 <code>spdk_bdev</code> 或 <code>spdk_nvme</code> 的路径，<code>spdk_json_conf</code> 需指定第三步中生成的 JSON 文件。</p><p>FIO 配置文件示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[global]</span><br><span class="hljs-attr">ioengine</span>=&lt;spdk_repo&gt;/build/fio/spdk_bdev <br><span class="hljs-attr">spdk_json_conf</span>=/tmp/bdev.json<br><br><span class="hljs-attr">thread</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">direct</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">group_reporting</span>=<span class="hljs-number">1</span><br><br><span class="hljs-attr">bs</span>=<span class="hljs-number">4</span>k<br><span class="hljs-attr">rw</span>=randread<br><span class="hljs-attr">rwmixread</span>=<span class="hljs-number">70</span><br><span class="hljs-attr">time_based</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">runtime</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">norandommap</span>=<span class="hljs-number">1</span><br><br><span class="hljs-section">[filename0]</span><br><span class="hljs-attr">filename</span>=Nvme0n1<br><span class="hljs-attr">iodepth</span>=<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h2 id="五运行fio">五、运行FIO</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo fio fio.conf<br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs routeros">filename0: (<span class="hljs-attribute">g</span>=0): <span class="hljs-attribute">rw</span>=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, <span class="hljs-attribute">ioengine</span>=spdk_bdev, <span class="hljs-attribute">iodepth</span>=8<br>fio-3.36-19-gbdf99<br>Starting 1 thread<br>Jobs: 1 (<span class="hljs-attribute">f</span>=1): [r(1)][100.0%][<span class="hljs-attribute">r</span>=2957MiB/s][<span class="hljs-attribute">r</span>=757k IOPS][eta 00m:00s]<br>filename0: (<span class="hljs-attribute">groupid</span>=0, <span class="hljs-attribute">jobs</span>=1): err= 0: <span class="hljs-attribute">pid</span>=47257: Fri Mar  1 08:09:14 2024<br>  read: <span class="hljs-attribute">IOPS</span>=754k, <span class="hljs-attribute">BW</span>=2944MiB/s (3087MB/s)(28.8GiB/10001msec)<br>    slat (nsec): <span class="hljs-attribute">min</span>=142, <span class="hljs-attribute">max</span>=22523, <span class="hljs-attribute">avg</span>=153.40, <span class="hljs-attribute">stdev</span>=38.74<br>    clat (usec): <span class="hljs-attribute">min</span>=2, <span class="hljs-attribute">max</span>=346, <span class="hljs-attribute">avg</span>=10.07, stdev= 1.91<br>     lat (usec): <span class="hljs-attribute">min</span>=2, <span class="hljs-attribute">max</span>=346, <span class="hljs-attribute">avg</span>=10.23, stdev= 1.91<br>    clat percentiles (nsec):<br>     |  1.00th=[ 5472],  5.00th=[ 7648], 10.00th=[ 8512], 20.00th=[ 9024],<br>     | 30.00th=[ 9408], 40.00th=[ 9664], 50.00th=[ 9920], 60.00th=[10176],<br>     | 70.00th=[10560], 80.00th=[10944], 90.00th=[11840], 95.00th=[13376],<br>     | 99.00th=[15680], 99.50th=[16768], 99.90th=[20352], 99.95th=[21632],<br>     | 99.99th=[28544]<br>   bw (  MiB/s): min= 2845, max= 2960, <span class="hljs-attribute">per</span>=100.00%, <span class="hljs-attribute">avg</span>=2945.67, <span class="hljs-attribute">stdev</span>=24.66, <span class="hljs-attribute">samples</span>=19<br>   iops        : <span class="hljs-attribute">min</span>=728552, <span class="hljs-attribute">max</span>=757862, <span class="hljs-attribute">avg</span>=754091.26, <span class="hljs-attribute">stdev</span>=6312.12, <span class="hljs-attribute">samples</span>=19<br>  lat (usec)   : <span class="hljs-attribute">4</span>=0.07%, <span class="hljs-attribute">10</span>=52.90%, <span class="hljs-attribute">20</span>=46.92%, <span class="hljs-attribute">50</span>=0.11%, <span class="hljs-attribute">100</span>=0.01%<br>  lat (usec)   : <span class="hljs-attribute">250</span>=0.01%, <span class="hljs-attribute">500</span>=0.01%<br>  cpu          : <span class="hljs-attribute">usr</span>=99.97%, <span class="hljs-attribute">sys</span>=0.00%, <span class="hljs-attribute">ctx</span>=31, <span class="hljs-attribute">majf</span>=0, <span class="hljs-attribute">minf</span>=0<br>  IO depths    : <span class="hljs-attribute">1</span>=0.1%, <span class="hljs-attribute">2</span>=0.1%, <span class="hljs-attribute">4</span>=41.0%, <span class="hljs-attribute">8</span>=58.8%, <span class="hljs-attribute">16</span>=0.0%, <span class="hljs-attribute">32</span>=0.0%, &gt;=<span class="hljs-attribute">64</span>=0.0%<br>     submit    : <span class="hljs-attribute">0</span>=0.0%, <span class="hljs-attribute">4</span>=100.0%, <span class="hljs-attribute">8</span>=0.0%, <span class="hljs-attribute">16</span>=0.0%, <span class="hljs-attribute">32</span>=0.0%, <span class="hljs-attribute">64</span>=0.0%, &gt;=<span class="hljs-attribute">64</span>=0.0%<br>     complete  : <span class="hljs-attribute">0</span>=0.0%, <span class="hljs-attribute">4</span>=99.7%, <span class="hljs-attribute">8</span>=0.3%, <span class="hljs-attribute">16</span>=0.0%, <span class="hljs-attribute">32</span>=0.0%, <span class="hljs-attribute">64</span>=0.0%, &gt;=<span class="hljs-attribute">64</span>=0.0%<br>     issued rwts: <span class="hljs-attribute">total</span>=7537136,0,0,0 <span class="hljs-attribute">short</span>=0,0,0,0 <span class="hljs-attribute">dropped</span>=0,0,0,0<br>     latency   : <span class="hljs-attribute">target</span>=0, <span class="hljs-attribute">window</span>=0, <span class="hljs-attribute">percentile</span>=100.00%, <span class="hljs-attribute">depth</span>=8<br><br><span class="hljs-built_in">Run</span> status<span class="hljs-built_in"> group </span>0 (all jobs):<br>   READ: <span class="hljs-attribute">bw</span>=2944MiB/s (3087MB/s), 2944MiB/s-2944MiB/s (3087MB/s-3087MB/s), <span class="hljs-attribute">io</span>=28.8GiB (30.9GB), <span class="hljs-attribute">run</span>=10001-10001msec<br></code></pre></td></tr></table></figure><h2 id="六zns性能测试">六、ZNS性能测试</h2><p>SPDK FIO 插件支持 ZNS SSD 性能测试。详情请参考<a href="https://github.com/spdk/spdk/blob/master/app/fio/bdev/README.md">ZNS性能测试</a>。</p>]]></content>
    
    
    <categories>
      
      <category>SPDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SPDK</tag>
      
      <tag>FIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.RAII and smart pointer</title>
    <link href="/2024/02/12/11-RAII-and-smart-pointer/"/>
    <url>/2024/02/12/11-RAII-and-smart-pointer/</url>
    
    <content type="html"><![CDATA[<h2 id="一资源管理与raii原则">一、资源管理与RAII原则</h2><p>在C++编程中，资源泄漏是一个常见问题，尤其是在异常发生时。为了确保资源总是被正确释放，C++引入了RAII（Resource Acquisition Is Initialization）原则。</p><h3 id="raii原则">1.1 RAII原则</h3><p>RAII是一种资源管理模型，确保使用对象自动管理资源。按照RAII原则，资源在对象构造时获取，在对象析构时释放。这样可以保证即使在发生异常的情况下资源也能被正确释放。</p><p>更直观的名字是CADRE（Constructor Acquires, Destructor Releases），强调构造函数获取资源，析构函数释放资源的概念。</p><h3 id="为什么使用raii">1.2 为什么使用RAII？</h3><ul><li>对象在创建后立即可用，无需额外的初始化步骤。</li><li>对象永远不处于半有效状态，要么完全管理其资源，要么在异常发生时自动释放资源。</li><li>析构函数总是在对象离开作用域时调用，因此资源总会被释放。</li></ul><h3 id="raii的实践">1.3 RAII的实践</h3><p>以下几种都会出现RAII问题：</p><p><img src="image-20240212211115886.png" /></p><h4 id="文件操作示例">文件操作示例</h4><p>不遵循RAII原则的代码示例与遵循RAII原则的代码示例对比：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 不遵循RAII</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFile</span><span class="hljs-params">()</span> </span>&#123;<br>    ifstream input;<br>    input.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;hamlet.txt&quot;</span>);<br>    string line;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(input, line)) &#123;<br>        cout &lt;&lt; line &lt;&lt; endl;<br>    &#125;<br>    input.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-comment">// 遵循RAII</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFile</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-string">&quot;hamlet.txt&quot;</span>)</span></span>;<br>    string line;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(input, line)) &#123;<br>        cout &lt;&lt; line &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 不需要调用close，ifstream的析构函数会自动关闭文件</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="锁的管理示例">锁的管理示例</h4><p>使用<code>lock_guard</code>自动管理互斥锁，避免忘记释放锁或异常导致锁未释放：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 不遵循RAII</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanDatabase</span><span class="hljs-params">(mutex &amp;databaseLock, map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;database)</span> </span>&#123;<br>    databaseLock.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-comment">// 修改数据库</span><br>    databaseLock.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-comment">// 遵循RAII</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanDatabase</span><span class="hljs-params">(mutex &amp;databaseLock, map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;database)</span> </span>&#123;<br>    <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(databaseLock)</span></span>;<br>    <span class="hljs-comment">// 修改数据库，即使发生异常也不需要手动解锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>lock_guard</code>的简化实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">lock_guard</span><span class="hljs-params">(mutex &amp;lock)</span> : acquired_lock(lock) &#123;</span> acquired_lock.<span class="hljs-built_in">lock</span>(); &#125;<br>    ~<span class="hljs-built_in">lock_guard</span>() &#123; acquired_lock.<span class="hljs-built_in">unlock</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    mutex &amp;acquired_lock;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二raii-和智能指针">二、RAII 和智能指针</h2><h3 id="非raii示例">2.1 非RAII示例</h3><p>使用原始指针管理内存，存在异常时资源泄露风险：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rawPtrFn</span><span class="hljs-params">()</span> </span>&#123;<br>    Node* n = <span class="hljs-keyword">new</span> Node;<br>    <span class="hljs-comment">// 若异常抛出，n所指向的内存将不会被释放</span><br>    <span class="hljs-keyword">delete</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="c中的智能指针">2.2 C++中的智能指针</h3><p>C++提供了几种“智能”指针来自动管理资源，遵循RAII原则：</p><ul><li><code>std::unique_ptr</code>：独占所指资源，不可复制，但可以移动。</li><li><code>std::shared_ptr</code>：共享所指资源，可复制，引用计数为零时释放资源。</li><li><code>std::weak_ptr</code>：不拥有资源，用于解决<code>std::shared_ptr</code>间的循环引用问题。</li></ul><h3 id="stdunique_ptr">2.3 std::unique_ptr</h3><p><code>std::unique_ptr</code>独占其所指向的资源，并在析构时释放该资源。它不能被复制，防止多个指针同时管理同一资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useUniquePtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;Node&gt; <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Node)</span></span>;<br>    <span class="hljs-comment">// 使用n</span><br>&#125; <span class="hljs-comment">// n所指向的Node对象在此处被自动释放</span><br></code></pre></td></tr></table></figure><p>尝试复制<code>std::unique_ptr</code>会导致编译错误，因为其复制构造函数和复制赋值操作符被删除。</p><p>假设可以复制<code>std::unique_ptr</code>，会导致的错误：</p><figure><img src="image-20240212212211214.png" alt="" /><figcaption>1.make a unique ptr</figcaption></figure><figure><img src="image-20240212212230847.png" alt="" /><figcaption>2.make a copy of this pointer</figcaption></figure><figure><img src="image-20240212212251048.png" alt="" /><figcaption>3.y goes out of scope</figcaption></figure><figure><img src="image-20240212212314735.png" alt="" /><figcaption>4.crash</figcaption></figure><h3 id="stdshared_ptr">2.4 std::shared_ptr</h3><p><code>std::shared_ptr</code>允许多个指针共享对同一资源的拥有权。当最后一个<code>shared_ptr</code>被销毁时，资源才会被释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br>    &#123;<br>        std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; p2 = p1;<br>        <span class="hljs-comment">// p1 和 p2 均有效</span><br>    &#125;<br>    <span class="hljs-comment">// 仅p1有效</span><br>&#125;<br><span class="hljs-comment">// 此处p1被销毁，其所指资源被释放</span><br></code></pre></td></tr></table></figure><h3 id="stdweak_ptr">2.5 std::weak_ptr</h3><p><code>std::weak_ptr</code>用于指向<code>std::shared_ptr</code>管理的对象，但不影响对象的引用计数。它主要用于解决<code>std::shared_ptr</code>之间的循环引用问题。</p><h3 id="智能指针创建函数">2.6 智能指针创建函数</h3><p>推荐使用标准库提供的智能指针创建函数，因为它们可以更安全地分配资源，并减少代码中的裸<code>new</code>操作。</p><ul><li><code>std::make_unique&lt;T&gt;(args...)</code>：创建<code>std::unique_ptr</code>。</li><li><code>std::make_shared&lt;T&gt;(args...)</code>：创建<code>std::shared_ptr</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::unique_ptr&lt;T&gt; up = std::<span class="hljs-built_in">make_unique</span>&lt;T&gt;();<br>std::shared_ptr&lt;T&gt; sp = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;();<br></code></pre></td></tr></table></figure><p>总是优先使用<code>std::make_unique()</code>和<code>std::make_shared()</code>创建智能指针，它们不仅提供了类型安全和异常安全保证，还可以简化代码并提高可读性。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>RAII</tag>
      
      <tag>smart pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.Move Semantic</title>
    <link href="/2024/02/12/10-Move-Semantic/"/>
    <url>/2024/02/12/10-Move-Semantic/</url>
    
    <content type="html"><![CDATA[<h2 id="一lvalues-和-rvalues-简介">一、lvalues 和 rvalues 简介</h2><ul><li><strong>lvalue（左值）</strong>：具有持久存储地址的表达式或变量，可以位于赋值符号的左侧。</li><li><strong>rvalue（右值）</strong>：代表临时对象或无法标识的值，常出现在赋值符号的右侧，不能被赋值。</li></ul><h3 id="例子">1.1 例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> val = <span class="hljs-number">2</span>;                 <span class="hljs-comment">// 2 是 r-value</span><br><span class="hljs-type">int</span> *ptr = &amp;val;             <span class="hljs-comment">// &amp;val 是 r-value</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v1&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;     <span class="hljs-comment">// 1, 2, 3 是 r-values</span><br><br><span class="hljs-keyword">auto</span> v4 = v1 + v2;           <span class="hljs-comment">// v1 + v2 是 r-value</span><br><span class="hljs-keyword">auto</span> v5 = v1 += v4;          <span class="hljs-comment">// v1 += v4 的结果是 lvalue</span><br><br><span class="hljs-type">size_t</span> size = v1.<span class="hljs-built_in">size</span>();     <span class="hljs-comment">// v1.size() 是 r-value</span><br>val = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(size);<span class="hljs-comment">// static_cast&lt;int&gt;(size) 是 r-value</span><br><br>v1[<span class="hljs-number">1</span>] = <span class="hljs-number">4</span> * val;             <span class="hljs-comment">// 4 * val 是 r-value</span><br></code></pre></td></tr></table></figure><h3 id="生命周期差异">1.2 生命周期差异</h3><ul><li><strong>lvalue</strong> 的生命周期取决于其作用域。</li><li><strong>rvalue</strong> 的生命周期通常在表达式结束时即结束，除非被存储或绑定到引用延长。</li></ul><h3 id="lvalue-和-rvalue-引用">1.3 lvalue 和 rvalue 引用</h3><ul><li><strong>lvalue 引用</strong>（<code>T&amp;</code>）：绑定到 lvalues。</li><li><strong>rvalue 引用</strong>（<code>T&amp;&amp;</code>）：专门绑定到 rvalues。</li><li><strong>const lvalue 引用</strong>（<code>const T&amp;</code>）：可以绑定到 lvalues 和 rvalues，常用于传递参数。</li></ul><p><strong>问题解答</strong>：对于 <code>auto&amp;&amp; v4 = v1 + v2;</code>，尽管 <code>v4</code> 绑定了一个 rvalue，<code>v4</code> 本身作为一个引用是 lvalue。</p><p><img src="image-20240212173656785.png" /></p><h2 id="二移动操作">二、移动操作</h2><p>移动语义允许从临时对象转移资源至新对象，减少资源的不必要复制，从而提高性能。</p><h3 id="特殊成员函数">2.1 特殊成员函数</h3><ul><li><strong>移动构造函数</strong>：从存在的 rvalue 创建新对象。</li><li><strong>移动赋值操作符</strong>：用存在的 rvalue 替换现有对象。</li></ul><h3 id="示例">2.2 示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 移动构造函数示例</span><br><span class="hljs-built_in">MyVector</span>(MyVector&lt;T&gt; &amp;&amp;other)<br>    : <span class="hljs-built_in">elems</span>(std::<span class="hljs-built_in">move</span>(other.elems)), <span class="hljs-built_in">logicalSize</span>(other.logicalSize), <span class="hljs-built_in">allocatedSize</span>(other.allocatedSize) &#123;<br>    other.elems = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 移动赋值操作符示例</span><br>MyVector&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(MyVector&lt;T&gt; &amp;&amp;rhs) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>        <span class="hljs-keyword">delete</span>[] elems;<br>        elems = std::<span class="hljs-built_in">move</span>(rhs.elems);<br>        rhs.elems = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：拷贝构造函数和拷贝赋值操作符的参数是 <code>const T&amp;</code>，因此它们适用于 lvalues 和 rvalues。但如果你实现了一个接受 <code>T&amp;&amp;</code> 参数的移动构造函数和移动赋值操作符，那么编译器将为 rvalues 优先选择 <code>T&amp;&amp;</code>。</p></blockquote><h2 id="三stdmove简介">三、<code>std::move</code>简介</h2><p>当执行移动操作时，正确使用 <code>std::move</code> 是实现有效移动语义的关键，因为它确保了资源能够被正确地移动而非拷贝。</p><h3 id="移动操作的常见误区">3.1 移动操作的常见误区</h3><p>让我们以 <code>RandomBag</code> 类为例来探讨一个常见的误区。<code>RandomBag</code> 类包含一个类型为 <code>vector&lt;int&gt;</code> 的成员变量 <code>elems</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomBag</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RandomBag</span>();<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; elems;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果在移动赋值操作中直接赋值而不使用 <code>std::move</code>，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">RandomBag &amp;RandomBag::<span class="hljs-keyword">operator</span>=(RandomBag &amp;&amp;rhs) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>        elems = rhs.elems; <span class="hljs-comment">// 这实际上是拷贝操作</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的误区在于，尽管 <code>rhs</code> 是 r-value 引用，但未经 <code>std::move</code> 处理，<code>rhs.elems</code> 在赋值时被视为 l-value，导致执行的是拷贝而非预期的移动操作。</p><h3 id="正确使用-stdmove">3.2 正确使用 <code>std::move</code></h3><p>为了确保资源被移动，我们应该这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">elems = std::<span class="hljs-built_in">move</span>(rhs.elems);<br></code></pre></td></tr></table></figure><p>通过 <code>std::move</code>，<code>rhs.elems</code> 被转换为 r-value，触发 <code>vector&lt;int&gt;</code> 的移动赋值操作，从而实现资源的有效移动。重要的是要记住，<code>std::move</code> 本身不移动任何东西；它仅将其参数转换为 r-value，真正的移动操作依赖于移动构造函数或移动赋值操作符。</p><h2 id="四举例通用的-swap-函数">四、举例：通用的 swap 函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    T temp = std::<span class="hljs-built_in">move</span>(a);<br>    a = std::<span class="hljs-built_in">move</span>(b);<br>    b = std::<span class="hljs-built_in">move</span>(temp);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五规则总结">五、规则总结</h2><ul><li><strong>规则五</strong>：如果你显式定义（或删除）了拷贝构造函数、拷贝赋值、移动构造函数、移动赋值或析构函数中的任何一个，你应该为所有五个定义（或删除）。</li><li><strong>规则零</strong>：如果默认操作符工作正常，则不要定义自定义的特殊成员函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomBag</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RandomBag</span>();<br>    <span class="hljs-built_in">RandomBag</span>(<span class="hljs-type">const</span> RandomBag &amp;other) = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">RandomBag</span>(RandomBag &amp;&amp;other) = <span class="hljs-keyword">default</span>;<br>    RandomBag &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RandomBag &amp;rhs) = <span class="hljs-keyword">default</span>;<br>    RandomBag &amp;<span class="hljs-keyword">operator</span>=(RandomBag &amp;&amp;rhs) = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeRandom</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; elems;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六示例代码">六、示例代码</h2><p><a href="/downloads/move_semantics.zip">点击下载示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>std::move</tag>
      
      <tag>Move constructor</tag>
      
      <tag>Move assignment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.Special member</title>
    <link href="/2024/02/12/9-Special-member/"/>
    <url>/2024/02/12/9-Special-member/</url>
    
    <content type="html"><![CDATA[<h2 id="一c特殊成员函数简介">一、C++特殊成员函数简介</h2><ul><li>C++自动为类生成的特殊成员函数包括：<ul><li><strong>默认构造函数</strong>：无参数创建对象。</li><li><strong>拷贝构造函数</strong>：以另一个现有对象为模板创建新对象。</li><li><strong>拷贝赋值操作符</strong>：用另一个现有对象替换现有对象的内容。</li><li><strong>析构函数</strong>：对象离开作用域时被销毁。</li></ul></li></ul><h3 id="函数调用示例">1.1 函数调用示例</h3><p>在以下示例中，每行代码调用的特殊成员函数是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">MyVector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">function</span><span class="hljs-params">(MyVector&lt;<span class="hljs-type">int</span>&gt; vec0)</span> </span>&#123; <span class="hljs-comment">// 拷贝构造函数</span><br>    MyVector&lt;<span class="hljs-type">int</span>&gt; vec1; <span class="hljs-comment">// 默认构造函数</span><br>    MyVector&lt;<span class="hljs-type">int</span>&gt; vec2&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 初始化列表构造函数</span><br>    <span class="hljs-function">MyVector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec3</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 错误：尝试声明函数</span><br>    <span class="hljs-function">MyVector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec4</span><span class="hljs-params">(vec2)</span></span>; <span class="hljs-comment">// 拷贝构造函数</span><br>    MyVector&lt;<span class="hljs-type">int</span>&gt; vec5&#123;&#125;; <span class="hljs-comment">// 默认构造函数</span><br>    MyVector&lt;<span class="hljs-type">int</span>&gt; vec6&#123;vec3 + vec4&#125;; <span class="hljs-comment">// 拷贝（或移动）构造函数</span><br>    MyVector&lt;<span class="hljs-type">int</span>&gt; vec7 = vec4; <span class="hljs-comment">// 拷贝构造函数</span><br>    vec7 = vec2; <span class="hljs-comment">// 拷贝赋值操作符</span><br>    <span class="hljs-keyword">return</span> vec7; <span class="hljs-comment">// （可能的）拷贝构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拷贝构造函数">1.2 拷贝构造函数</h3><p>拷贝构造函数负责创建对象的深拷贝，必要时进行深度复制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringVector::<span class="hljs-built_in">StringVector</span>(<span class="hljs-type">const</span> StringVector &amp;other)<br>    : _logicalSize(other._logicalSize), _allocatedSize(other._allocatedSize) &#123;<br>    _elems = <span class="hljs-keyword">new</span> ValueType[_allocatedSize];<br>    std::<span class="hljs-built_in">copy</span>(other.<span class="hljs-built_in">begin</span>(), other.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">begin</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拷贝赋值操作符">1.3 拷贝赋值操作符</h3><p>拷贝赋值操作符需释放对象当前资源后，执行拷贝。注意自赋值情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringVector&amp; StringVector::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> StringVector &amp;rhs) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>        <span class="hljs-keyword">delete</span>[] _elems;<br>        _logicalSize = rhs._logicalSize;<br>        _allocatedSize = rhs._allocatedSize;<br>        _elems = <span class="hljs-keyword">new</span> ValueType[_allocatedSize];<br>        std::<span class="hljs-built_in">copy</span>(rhs.<span class="hljs-built_in">begin</span>(), rhs.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">begin</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除操作">1.4 删除操作</h3><p>通过显式删除特殊成员函数，可以阻止对象被拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggedVector</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LoggedVector</span>(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> denom);<br>    ~<span class="hljs-built_in">LoggedVector</span>();<br>    <span class="hljs-built_in">LoggedVector</span>(<span class="hljs-type">const</span> LoggedVector &amp;rhs) = <span class="hljs-keyword">delete</span>;<br>    LoggedVector &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> LoggedVector &amp;rhs) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="三法则与零法则">1.5 三法则与零法则</h3><ul><li><strong>三法则</strong>：如果你需要自定义<strong>析构函数、拷贝构造函数或拷贝赋值操作符</strong>中的任何一个，你可能需要定义所有三个，因为这意味着你的类有资源管理需求。</li><li><strong>零法则</strong>：如果默认操作符满足需求，最好不要自定义这些特殊成员函数。</li></ul><h2 id="二拷贝问题与优化">二、拷贝问题与优化</h2><p>在C++中，频繁的对象拷贝可能导致性能问题。考虑以下代码片段，它演示了在一个简单场景中对象如何被创建和拷贝：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">StringVector <span class="hljs-title">findAllWords</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;filename)</span> </span>&#123;<br>    StringVector words; <span class="hljs-comment">// 创建局部StringVector对象</span><br>    <span class="hljs-comment">// 使用ifstream从文件名读取数据</span><br>    <span class="hljs-keyword">return</span> words; <span class="hljs-comment">// 返回局部对象的拷贝</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    StringVector words; <span class="hljs-comment">// 默认构造函数创建对象</span><br>    words = <span class="hljs-built_in">findAllWords</span>(<span class="hljs-string">&quot;words.txt&quot;</span>); <span class="hljs-comment">// 调用findAllWords函数</span><br>    <span class="hljs-comment">// 打印words内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在没有编译器优化的情况下，这段代码会导致多次StringVector对象的创建和拷贝：</p><ol type="1"><li><code>main</code>函数中声明的<code>words</code>对象通过默认构造函数创建。</li><li><code>findAllWords</code>函数中的<code>words</code>对象通过默认构造函数创建。</li><li><code>findAllWords</code>返回时，通过拷贝构造函数创建一个临时对象。</li><li>将临时对象赋值给<code>main</code>中的<code>words</code>对象，调用拷贝赋值操作符。</li></ol><p><img src="image-20240212164958864.png" /></p><p>为了减少不必要的对象拷贝，C++提供了几种优化机制：</p><h3 id="拷贝省略与返回值优化rvo">2.1 拷贝省略与返回值优化（RVO）</h3><p>编译器可以优化掉一些不必要的拷贝，特别是函数返回时的临时对象。这种优化称为返回值优化（RVO），直接在调用方的空间创建返回对象，避免额外的拷贝。现代C++编译器智能地应用RVO，减少性能损耗。</p><p><img src="image-20240212164932394.png" /></p><h3 id="移动语义">2.2 移动语义</h3><p>C++11引入的移动语义允许对象的资源“转移”而非传统意义上的拷贝。通过使用移动构造函数和移动赋值操作符，可以有效地将一个对象的状态或资源转移到另一个对象，从而避免深度拷贝带来的开销。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">StringVector words = <span class="hljs-built_in">findAllWords</span>(<span class="hljs-string">&quot;words.txt&quot;</span>);<br></code></pre></td></tr></table></figure><p>如果<code>findAllWords</code>返回的对象利用移动语义，那么这里将不会发生深度拷贝，而是资源的转移。</p><p>更详细的移动语义后续讲解。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Copy constructor</tag>
      
      <tag>Copy assignment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.Template Class</title>
    <link href="/2024/02/12/8-Template-Class/"/>
    <url>/2024/02/12/8-Template-Class/</url>
    
    <content type="html"><![CDATA[<h2 id="一类模板简介">一、类模板简介</h2><p>类模板提供了定义泛型类的方法，使得类能够处理不同的数据类型。这增强了代码的复用性和灵活性。</p><h3 id="基本定义">1.1 基本定义</h3><p>类模板使用<code>template</code>关键字定义，后跟模板参数列表。这些参数可以使用<code>typename</code>或<code>class</code>关键字声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPair</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">T1 <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">T2 <span class="hljs-title">getSecond</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    T1 first;<br>    T2 second;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="成员函数实现">1.2 成员函数实现</h3><p>类外成员函数实现需要前置模板参数声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br>T1 MyPair&lt;T1, T2&gt;::<span class="hljs-built_in">getFirst</span>() &#123;<br>    <span class="hljs-keyword">return</span> first;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br>T2 MyPair&lt;T1, T2&gt;::<span class="hljs-built_in">getSecond</span>() &#123;<br>    <span class="hljs-keyword">return</span> second;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>成员函数定义前需要重申模板参数。</li><li>使用<code>MyPair&lt;T1, T2&gt;</code>来指定函数所属的类模板。</li></ul><h2 id="二member-types">二、Member Types</h2><p>模板类型中的成员类型（例如迭代器）提供了访问依赖类型的标准方法。</p><h3 id="语法">2.1 语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ValueType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealVector</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> iterator = ValueType*;<br>    <span class="hljs-keyword">using</span> const_iterator = <span class="hljs-type">const</span> ValueType*;<br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">const_iterator <span class="hljs-title">cbegin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">const_iterator <span class="hljs-title">cend</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    ValueType* elems;<br>    <span class="hljs-type">size_t</span> size;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="接口实现">2.2 接口实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ValueType&gt;<br><span class="hljs-keyword">typename</span> RealVector&lt;ValueType&gt;::iterator RealVector&lt;ValueType&gt;::<span class="hljs-built_in">begin</span>() &#123;<br>    <span class="hljs-keyword">return</span> elems;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ValueType&gt;<br><span class="hljs-keyword">typename</span> RealVector&lt;ValueType&gt;::const_iterator RealVector&lt;ValueType&gt;::<span class="hljs-built_in">cbegin</span>() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> elems;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ValueType&gt;<br><span class="hljs-keyword">typename</span> RealVector&lt;ValueType&gt;::iterator RealVector&lt;ValueType&gt;::<span class="hljs-built_in">end</span>() &#123;<br>    <span class="hljs-keyword">return</span> elems + size;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ValueType&gt;<br><span class="hljs-keyword">typename</span> RealVector&lt;ValueType&gt;::const_iterator RealVector&lt;ValueType&gt;::<span class="hljs-built_in">cend</span>() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> elems + size;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>成员类型定义在类命名空间内。</li><li>使用<code>typename</code>明确模板参数类型中的嵌套类型。</li></ul><h2 id="三模板类头文件与源文件编写">三、模板类头文件与源文件编写</h2><p>为确保模板类正常编译，源文件内容应包含在头文件内。</p><p>原因：模板在实例化前不生成代码，因此需要将实现(.cpp)包含在头文件(.h)中。</p><p>例如：</p><p><strong>realvector.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> REALVECTOR_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REALVECTOR_H</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ValueType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealVector</span> &#123;<br>    <span class="hljs-comment">// 类定义</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;realvector.cpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// REALVECTOR_H</span></span><br></code></pre></td></tr></table></figure><h2 id="四示例代码">四、示例代码</h2><p><a href="/downloads/template_classes.zip">点击下载示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Template Class</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.Operator Overloading</title>
    <link href="/2024/02/11/7-Operator-Overloading/"/>
    <url>/2024/02/11/7-Operator-Overloading/</url>
    
    <content type="html"><![CDATA[<h2 id="一左值右值">一、左值&amp;右值</h2><ul><li>左值是可以标识的、具有地址的表达式或变量。左值通常代表着一个具体的内存位置，因此可以在赋值操作的左侧使用。</li><li>右值是临时的、不可标识的表达式或值。右值通常代表计算的结果或临时对象，只能出现在赋值操作的右侧。</li></ul><p>在重载操作符时，尤其需要注意返回值是左值还是右值，例如：</p><ul><li>默认情况下，+操作符返回一个右值，因此<code>(x + y) = 5;</code>的写法就是非法的。</li><li><code>myArray[5] = 137;</code>是合法的，因为<code>myArray[5]</code>的返回值是一个左值。</li></ul><p>若要创建一个返回左值的函数，则需让该函数返回一个非const引用，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string&amp; <span class="hljs-title">LValueFunction</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>若要创建一个返回右值的函数，则需让该函数返回一个const对象，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> string <span class="hljs-title">RValueFunction</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>因为返回类型被const修饰，因此类似<code>RValueFunction() = 137;</code>的代码自然是非法的。</p><h2 id="二重载复合赋值操作符op">二、重载复合赋值操作符：<code>op=</code></h2><p>复合赋值操作符用于在C++中修改对象自身，并通常作为成员函数实现。这些操作符允许你以一种简洁的方式更新对象的状态。基本的函数签名如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyClass&amp; <span class="hljs-keyword">operator</span> op= (<span class="hljs-type">const</span> ParameterType&amp; param);<br></code></pre></td></tr></table></figure><ul><li><code>op</code> 代表具体的操作符（如<code>+=</code>或<code>-=</code>）。</li><li><code>ParameterType</code> 表示传入参数的类型。</li></ul><h3 id="示例">2.1 示例</h3><p>考虑一个<code>Vector3D</code>类，它代表一个三维向量。我们将重载<code>+=</code>和<code>-=</code>操作符，以及一元的负号<code>-</code>操作符。</p><p><strong>类定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector3D</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Vector3D&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Vector3D&amp; other);<br>    Vector3D&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> Vector3D&amp; other);<br>    <span class="hljs-type">const</span> Vector3D <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM_COORDINATES = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">double</span> coordinates[NUM_COORDINATES];<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>操作符实现</strong></p><ol type="1"><li><strong>重载<code>+=</code>操作符</strong>：实现向量加法。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Vector3D&amp; Vector3D::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Vector3D&amp; other) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_COORDINATES; ++i) &#123;<br>        coordinates[i] += other.coordinates[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 支持链式调用</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>重载<code>-=</code>操作符</strong>：利用<code>+=</code>操作符和一元负号操作符来实现向量减法。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Vector3D Vector3D::<span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;<br>    Vector3D result;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_COORDINATES; ++i) &#123;<br>        result.coordinates[i] = -coordinates[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><strong>重载一元负号<code>-</code>操作符</strong>：返回向量的负值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Vector3D Vector3D::<span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;<br>    Vector3D result;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_COORDINATES; ++i) &#123;<br>        result.coordinates[i] = -coordinates[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三重载数学运算符-">三、重载数学运算符：<code>+</code>/<code>-</code></h2><p>重载数学运算符时，遵循以下一般原则确保代码的正确性和高效性：</p><h3 id="一般原则">3.1 一般原则</h3><ol type="1"><li><strong>返回值类型</strong>：为了避免返回对象被非预期修改，数学运算符应返回一个不允许修改的临时对象，通常是 <code>const MyClass</code> 类型。</li><li><strong>常量性</strong>：运算符不应修改其操作数，因此重载运算符的函数通常需要被声明为 <code>const</code>。</li><li><strong>自由函数</strong>：为了支持所有相关类型的操作数（包括那些不是类对象的），数学运算符通常作为自由函数（非成员函数）实现。</li><li><strong>效率</strong>：复合赋值运算符（如 <code>+=</code>、<code>-=</code>）通常比单独的数学运算符（如 <code>+</code>、<code>-</code>）更高效，因为复合赋值可以就地修改对象并返回引用，避免了额外的对象复制。</li></ol><h3 id="示例-1">3.2 示例</h3><p>假设存在一个<code>Matrix</code>类，我们想要支持标量乘法。直接将<code>*</code>运算符作为成员函数重载可能会限制其使用（如<code>2.71828 * myMatrix</code>将无法编译），因为左侧操作数不是<code>Matrix</code>类型。</p><p><strong>解决方案</strong></p><p>将乘法运算符<code>*</code>重载为自由函数，支持<code>double</code>和<code>Matrix</code>类型的操作数，并按顺序接收这两个参数。这样做可以无缝支持<code>double * Matrix</code>和<code>Matrix * double</code>两种运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Matrix <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> scalar, <span class="hljs-type">const</span> Matrix&amp; matrix) &#123;<br>    Matrix result = matrix;<br>    result *= scalar; <span class="hljs-comment">// 假设Matrix类已有 *= 运算符重载</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-type">const</span> Matrix <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Matrix&amp; matrix, <span class="hljs-type">double</span> scalar) &#123;<br>    <span class="hljs-keyword">return</span> scalar * matrix; <span class="hljs-comment">// 复用上一个运算符实现</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四重载元素选择运算符">四、重载元素选择运算符：<code>[]</code></h2><p>重载元素选择运算符<code>[]</code>允许类实例通过下标操作访问其元素，类似于数组。为了使这种操作更符合直觉并兼容不同的使用场景（如对常量对象的访问），通常需要提供两个版本的运算符重载：一个用于非常量对象，另一个用于常量对象。</p><h3 id="示例-2">4.1 示例</h3><p>在自定义的<code>string</code>类中，<code>[]</code>运算符的重载允许通过下标访问字符串中的字符。需要实现两个版本：</p><ol type="1"><li><strong>非常量版本</strong>：返回一个可修改的字符引用，允许修改通过下标访问的字符。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> &amp;string::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123;<br>    <span class="hljs-keyword">return</span> theString[index]; <span class="hljs-comment">// 假设theString是字符数组</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>常量版本</strong>：当<code>string</code>对象被声明为常量时，这个版本的运算符允许访问下标对应的字符，但不允许修改它。返回一个常量引用。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; string::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> theString[index]; <span class="hljs-comment">// 返回字符的常量引用</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重要性">4.2 重要性</h3><ul><li><strong>返回左值</strong>：这两个重载的<code>[]</code>运算符都返回引用（一个是<code>char&amp;</code>，另一个是<code>const char&amp;</code>），这允许左值语义，例如允许赋值操作。</li><li><strong>常量对象兼容</strong>：提供<code>const</code>版本的运算符重载使得在常量对象上使用<code>[]</code>运算符成为可能，保持了对常量对象的只读访问。</li></ul><h2 id="五重载流插入操作符">五、重载流插入操作符 <code>&lt;&lt;</code></h2><p>重载流插入操作符 <code>&lt;&lt;</code> 允许自定义类型以流式的方式输出到标准输出流（如<code>std::cout</code>）或其他输出流中。以下是实现这一功能时的关键考虑事项：</p><h3 id="基本原则">5.1 基本原则</h3><ol type="1"><li><strong>返回类型</strong>：为了支持连续的流式输出操作（链式调用），如<code>cout &lt;&lt; obj1 &lt;&lt; obj2;</code>。<code>operator&lt;&lt;</code> 应返回对输出流的非<code>const</code>引用。</li><li><strong>实现为自由函数</strong>：为了正确重载对<code>ostream</code>类型的操作符，<code>operator&lt;&lt;</code> 需要实现为自由函数（非成员函数），这样做可以确保操作符的第一个参数是输出流对象的引用。</li><li><strong>友元函数声明</strong>：将这个自由函数声明为类的友元，可以使它访问类的私有或保护成员变量，便于输出类内部的信息。</li></ol><h3 id="示例实现">5.2 示例实现</h3><p>以下示例展示了如何为一个自定义类<code>MyClass</code>重载<code>&lt;&lt;</code>操作符，使其可以输出类的私有成员数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 其他成员函数...</span><br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; stream, <span class="hljs-type">const</span> MyClass&amp; mc);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> someData; <span class="hljs-comment">// 示例私有成员变量</span><br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; stream, <span class="hljs-type">const</span> MyClass&amp; mc) &#123;<br>    <span class="hljs-comment">// 实现重载的流插入操作符</span><br>    stream &lt;&lt; mc.someData; <span class="hljs-comment">// 假设要输出的是someData成员</span><br>    <span class="hljs-keyword">return</span> stream; <span class="hljs-comment">// 支持连续输出操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六重载递增操作符">六、重载递增（<code>++</code>）操作符</h2><p>在C++中，递增（<code>++</code>）和递减（<code>--</code>）操作符可以被重载以提供自定义类的特定行为。这些操作符有两种形式：前缀（<code>++x</code>，<code>--x</code>）和后缀（<code>x++</code>，<code>x--</code>）。</p><h3 id="前缀形式">6.1 前缀形式</h3><ul><li><strong>定义</strong>：前缀形式直接增加（或减少）变量的值，并返回变量的新值。它是一个更高效的操作，因为它不需要复制对象。</li><li><strong>返回类型</strong>：应返回对象的引用（<code>MyClass&amp;</code>），以允许链式操作。</li></ul><h3 id="后缀形式">6.2 后缀形式</h3><ul><li><p><strong>定义</strong>：后缀形式首先保存变量的原始值，然后增加（或减少）变量的值，最后返回变量原始值的副本。这个过程涉及到额外的复制操作，因此通常比前缀形式慢。</p></li><li><p><strong>返回类型</strong>：为了避免对返回的临时对象进行修改，通常返回对象的值（<code>const MyClass</code>）。</p></li><li><p><strong>区分参数</strong>：后缀操作符通过接受一个<code>int</code>参数来与前缀版本区分，这个参数通常不使用但必须存在。</p></li></ul><h3 id="示例-3">6.3 示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyClass&amp; <span class="hljs-keyword">operator</span>++();          <span class="hljs-comment">// 前缀递增重载</span><br>    <span class="hljs-type">const</span> MyClass <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 后缀递增重载</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 类成员变量</span><br>&#125;;<br><br><span class="hljs-comment">// 前缀递增实现</span><br>MyClass&amp; MyClass::<span class="hljs-keyword">operator</span>++() &#123;<br>    <span class="hljs-comment">// 实现递增逻辑</span><br>    *<span class="hljs-keyword">this</span> += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 后缀递增实现</span><br><span class="hljs-type">const</span> MyClass MyClass::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>    MyClass oldValue = *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 保存当前值</span><br>    ++(*<span class="hljs-keyword">this</span>);                <span class="hljs-comment">// 调用前缀递增</span><br>    <span class="hljs-keyword">return</span> oldValue;          <span class="hljs-comment">// 返回原始值</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七重载关系运算符">七、重载关系运算符</h2><p>一般而言，关系运算符要重载一整套，一旦有了<code>operator&lt;</code>的实现，就可以仅根据<code>operator&lt;</code>来定义所有其他五个关系操作符：</p><p><img src="image.png" /></p><h2 id="八类型转换机制">八、类型转换机制</h2><h3 id="转换构造函数">8.1 转换构造函数</h3><p>转换构造函数允许C++中的对象通过单个值的初始化实现类型的隐式转换。这种构造函数接受单一参数，使得类的对象可以从该参数类型隐式转换而来。</p><p><strong>示例</strong>：</p><p>定义一个<code>RationalNumber</code>类，它接受整数作为分子和分母（分母有默认值）的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RationalNumber</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RationalNumber</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 其他成员函数定义...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator, denominator;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这允许你通过以下方式隐式创建<code>RationalNumber</code>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">RationalNumber myNumber = <span class="hljs-number">137</span>; <span class="hljs-comment">// 隐式调用 RationalNumber(int, int)</span><br></code></pre></td></tr></table></figure><p>这行代码隐式地将整数<code>137</code>转换为<code>RationalNumber</code>类型，实际上调用的是<code>RationalNumber(137)</code>。</p><h3 id="转换操作符">8.2 转换操作符</h3><p>转换操作符是一种特殊的类成员函数，用于实现对象到另一种类型的隐式转换。这些操作符没有显式的返回类型声明，而是通过操作符本身隐式指定返回类型，并通常被声明为<code>const</code>方法。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">AnotherClass</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 转换为AnotherClass类型</span><br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 转换为int类型</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这些转换操作符允许<code>MyClass</code>对象在需要<code>AnotherClass</code>或<code>int</code>类型时自动转换。</p><h3 id="explicit关键字">8.3 <code>explicit</code>关键字</h3><p>为了防止不期望的隐式转换带来的潜在问题，C++提供了<code>explicit</code>关键字。<code>explicit</code>用于构造函数或转换操作符时，将禁止该构造函数或转换操作符参与隐式类型转换。</p><p><strong>示例</strong>：</p><p>将转换操作符声明为<code>explicit</code>，意味着这种类型转换只能显式进行，避免了隐式转换可能带来的意外行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyClass</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>; <span class="hljs-comment">// 阻止隐式转换</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 阻止隐式转换为bool类型</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>使用<code>explicit</code>关键字的构造函数或转换操作符要求必须显式进行类型转换，如使用<code>static_cast&lt;bool&gt;(obj)</code>进行转换，从而提高了代码的安全性和可读性。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Operator</tag>
      
      <tag>Overloading</tag>
      
      <tag>Left Value</tag>
      
      <tag>Right Value</tag>
      
      <tag>Conversion Operator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.Introduction to Class</title>
    <link href="/2024/02/08/6-Introduction-to-Class/"/>
    <url>/2024/02/08/6-Introduction-to-Class/</url>
    
    <content type="html"><![CDATA[<h2 id="一classes简介">一、Classes简介</h2><ul><li>头文件（.h）VS 源码（.cpp）</li><li>构造函数</li><li>析构函数</li><li>操作符重载</li><li>const</li></ul><h3 id="头文件.h">1.1 头文件(.h)</h3><p><img src="image-20240208163200168.png" /></p><h3 id="源码.cpp-.cc-etc.">1.2 源码(.cpp, .cc, etc.)</h3><p><img src="image-20240208163214944.png" /></p><h3 id="构造函数">1.3 构造函数</h3><p><img src="image-20240208163230536.png" /></p><p>构造函数可分为带参数和不带参数两种类型，其调用方式示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">FMRadio <span class="hljs-title">myRadio</span><span class="hljs-params">(<span class="hljs-number">88.5</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 使用带参数的构造函数创建对象</span><br>FMRadio myRadio;          <span class="hljs-comment">// 使用不带参数的构造函数创建对象</span><br></code></pre></td></tr></table></figure><p>但是，使用下列代码并不能正确调用不带参数的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">FMRadio <span class="hljs-title">myRadio</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 问题：这会被误解为一个函数声明</span><br></code></pre></td></tr></table></figure><p>该语句被编译器解释为一个函数声明，而非使用默认构造函数实例化对象。为了调用默认构造函数，应直接使用对象名而不加任何括号；若需调用带参数的构造函数，则需在括号内指定参数。</p><p><strong>关于默认构造函数</strong></p><p>当一个类被定义但未显式声明任何构造函数时，C++会自动生成一个默认无参构造函数，这个构造函数基本上不执行任何操作。</p><p>但是，一旦在类中定义了至少一个构造函数（无论是带参数还是不带参数的），C++将不再自动生成默认的无参构造函数。这可能导致在未明确定义无参构造函数的情况下尝试实例化类时遇到问题，如下例所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FMRadio</span> &#123; <br>    <span class="hljs-keyword">public</span>: <br>        <span class="hljs-built_in">FMRadio</span>(<span class="hljs-type">double</span> freq, <span class="hljs-type">int</span> vol); <span class="hljs-comment">// 自定义带参数构造函数</span><br>        <span class="hljs-comment">// ...</span><br>&#125;;<br><br>FMRadio myRadio; <span class="hljs-comment">// 问题：类未定义默认无参构造函数，此行代码会引发错误</span><br></code></pre></td></tr></table></figure><p>在这种情况下，若需要使用无参构造函数，必须自行定义之，或确保使用已定义的带参数构造函数进行对象的初始化。</p><h3 id="析构函数">1.4 析构函数</h3><p><img src="image-20240208163548686.png" /></p><h3 id="操作符重载">1.5 操作符重载</h3><p><img src="image-20240208163604114.png" /></p><h2 id="二const-correctness">二、Const Correctness</h2><h3 id="const-member-functions">2.1 Const Member Functions</h3><ul><li>类通常包含const和非const成员函数。const对象仅可调用const成员函数。</li><li>在const成员函数内，类的所有成员变量都被视作const，允许读取但禁止修改。</li><li>const成员函数不能调用非const成员函数，以防止间接修改对象状态。</li></ul><p><strong>示例：定义Point类的const成员函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y); <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// const成员函数，不修改任何成员变量</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x, y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Point::getX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// 仅返回成员变量x的值</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="const-references">2.2 Const References</h3><ul><li>使用const引用作为函数参数可以防止该函数修改传入的对象。</li><li>即使传递给函数的原始对象不是const，函数内部也会将其视为const，确保对象内容的不可变性。</li><li>可以将非const对象传递给接受const引用的函数，但不能将const对象传递给仅接受非const引用的函数，因为这违反了const的约束。</li></ul><p><strong>示例：使用const引用作参数的函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintVector</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-comment">// 在这里，vec被视为const，因此不能对其进行修改</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这种设计允许既可以传递const对象也可以传递非const对象到函数<code>PrintVector</code>，但在函数内部，vec始终被视作const，保障了数据的安全性和不变性。</li><li>采用const引用作为参数的做法不仅可以提高程序的安全性，还可以避免不必要的对象复制，提高效率。</li></ul><h3 id="const-and-pointers">2.3 Const and Pointers</h3><p>在C++中，const和指针结合使用时，主要涉及两种情形：<strong>指向常量的指针</strong>（pointer-to-const）和<strong>常量指针</strong>（const pointer）。</p><ul><li><strong>指向常量的指针（pointer-to-const）</strong>：这种指针可以指向一个常量数据，不允许通过指针修改其指向的数据，但允许指针本身改变，即可以指向另一块数据。<ul><li>声明方式：<code>const Type* myPointer</code> 或 <code>Type const* myPointer</code>。</li><li><strong>关键点</strong>：指针可以重新指向不同的地址，但不能通过指针修改所指向的值。</li></ul></li><li><strong>常量指针（const pointer）</strong>：这种指针的指向一旦设定就不可改变，但它指向的数据值是可以修改的（除非指向的数据本身被声明为const）。<ul><li>声明方式：<code>Type* const myConstPointer</code>。</li><li><strong>关键点</strong>：指针的指向固定不变，但所指向的数据可以修改。</li></ul></li></ul><p>区分这两者的简单方法是观察<code>const</code>关键字与<code>*</code>符号的位置关系：</p><ul><li><strong>指向常量的指针</strong>：<code>const</code>位于<code>*</code>的左侧。</li><li><strong>常量指针</strong>：<code>const</code>位于<code>*</code>的右侧。</li></ul><p>技巧：从右向左读变量声明可以帮助记忆：</p><ul><li><code>const int* ptr</code>：从右向左读为 <strong>"ptr is a pointer to a int that is const"</strong>。</li><li><code>int * const ptr</code>：从右向左读为 <strong>"ptr is a const pointer to a int"</strong>。</li></ul><p>指向常量的指针既可以指向const变量，也可以指向非const变量；而常量指针则主要关注指针本身的不变性，而非所指数据的不变性。</p><p>总结：</p><p><img src="image-20240208170034673.png" /></p><h3 id="const-iterators">2.4 Const Iterators</h3><p>迭代器在C++中被广泛用于遍历容器元素，其用法和行为与指针非常相似。然而，迭代器与指针在const性质上的表现有所不同。</p><ul><li><strong>迭代器的const性质：</strong><ul><li>声明为<code>const vector&lt;int&gt;::iterator itr</code>的迭代器，其行为类似于常量指针<code>int* const itr</code>，而不是指向常量的指针<code>const int* itr</code>。这意味着你可以修改迭代器指向的值，但不能改变迭代器本身的指向。</li><li>要创建一个只能读取元素但不能修改它们的迭代器（类似于<code>const int* itr</code>），应使用<code>const_iterator</code>。</li></ul></li></ul><p><strong>示例说明</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2312</span>&#125;;<br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;::iterator itr = v.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// itr的指向不可变，但可以修改其指向的元素</span><br>*itr = <span class="hljs-number">5</span>; <span class="hljs-comment">// 正确：可以修改itr指向的元素</span><br>++itr; <span class="hljs-comment">// 错误：itr是const，不能改变指向</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator citr = v.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// citr可以改变指向，但不可以修改其指向的元素</span><br>*citr = <span class="hljs-number">5</span>; <span class="hljs-comment">// 错误：citr指向的元素不可修改</span><br>++citr; <span class="hljs-comment">// 正确：可以改变citr的指向</span><br><span class="hljs-type">int</span> value = *citr; <span class="hljs-comment">// 正确：可以读取citr指向的元素</span><br></code></pre></td></tr></table></figure><ul><li>对于const对象或const引用的容器，应使用<code>const_iterator</code>来遍历其元素，以确保遍历过程中不会意外修改容器内容。</li><li><code>const_iterator</code>的支持是通过容器类中const重载的<code>begin()</code>和<code>end()</code>方法实现的，这些方法在容器对象为const时返回<code>const_iterator</code>，确保了只读访问。</li></ul><p><strong>容器类的const_iterator实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">vector</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 返回可修改元素的迭代器</span><br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">// 返回只读迭代器，用于const对象</span><br>    <span class="hljs-function">const_iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">const_iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// ...其他成员函数...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>通过这种方式，C++为容器元素的遍历提供了灵活的读写控制，同时确保了代码的安全性和可维护性。</p><h3 id="mutable关键字">2.5 Mutable关键字</h3><p>在C++中，<code>const</code>成员函数表明该函数不会修改对象的任何成员变量。然而，有些情况下，我们可能需要在<code>const</code>成员函数内部修改某些成员变量的状态。这时，<code>mutable</code>关键字就派上用场了。</p><p>使用<code>mutable</code>声明的成员变量可以在对象的<code>const</code>成员函数中被修改。这允许开发者在不破坏对象外部不可变承诺的前提下，灵活处理内部状态。</p><p>考虑一个需要缓存昂贵计算结果的类<code>CachedData</code>。为了在对象被声明为<code>const</code>时仍然能更新缓存，我们可以将缓存相关的成员变量声明为<code>mutable</code>。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedData</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CachedData</span>() : <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">cacheValue</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">cacheValid</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compute</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">// 假设为const成员函数</span><br>        <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>            cacheValue = <span class="hljs-comment">/* expensive computation */</span> value; <span class="hljs-comment">// 计算并缓存结果</span><br>            cacheValid = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记缓存为有效</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> cacheValue; &#125; <span class="hljs-comment">// 返回缓存值</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value; <span class="hljs-comment">// 原始数据</span><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> cacheValue; <span class="hljs-comment">// 可在const成员函数中修改的缓存值</span><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> cacheValid; <span class="hljs-comment">// 同上，标记缓存是否有效</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，尽管<code>CachedData</code>的实例可能被声明为<code>const</code>，<code>compute</code>方法仍可更新<code>cacheValue</code>和<code>cacheValid</code>。这是因为这两个成员变量被声明为<code>mutable</code>，从而使得我们能够在保持对象外观不变性的同时，提高内部处理效率和灵活性。</p><h2 id="三构造函数成员初始化列表">三、构造函数：成员初始化列表</h2><h3 id="c对象构造过程">3.1 C++对象构造过程</h3><p>在C++中，对象的构造过程，如果不借助成员初始化列表，一般遵循以下步骤：</p><ol type="1"><li><strong>内存分配</strong>：对象所需的内存空间被分配，此时成员变量尚未初始化，可能含有未定义的值。</li><li><strong>默认构造</strong>：为成员变量调用默认构造函数。对于基本类型，这一步不改变其未定义的状态；对于类类型，调用其默认构造函数。</li><li><strong>赋值操作</strong>：执行构造函数体中的赋值操作，对成员变量进行初始化。</li></ol><p>这个过程中，类类型的成员变量可能会经历两次初始化：首先是默认构造，随后是在构造函数体内的显式赋值。</p><h3 id="不使用初始化列表的构造示例">3.2 不使用初始化列表的构造示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SimpleClass</span>();<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> myInt;<br>    string myString;<br>    vector&lt;<span class="hljs-type">int</span>&gt; myVector;<br>&#125;;<br><br>SimpleClass::<span class="hljs-built_in">SimpleClass</span>() &#123;<br>    myInt = <span class="hljs-number">5</span>;<br>    myString = <span class="hljs-string">&quot;C++!&quot;</span>;<br>    myVector.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>获得足够的空间来容纳对象的所有数据成员。此时数据成员都为垃圾值：</li></ol><p><img src="image.png" /></p><ol start="2" type="1"><li>调用每个实例变量的默认构造函数。对于基本类型而言，依然保持垃圾值：</li></ol><p><img src="image-1.png" /></p><ol start="3" type="1"><li>调用构造函数来进行初始化：</li></ol><p><img src="image-2.png" /></p><p>在这个例子中，<code>myString</code>和<code>myVector</code>在被赋予新值前，已通过默认构造函数被初始化一次，导致效率降低。</p><h3 id="使用成员初始化列表优化">3.3 使用成员初始化列表优化</h3><p>使用成员初始化列表可以在构造对象时更加高效和直接地初始化成员变量，避免不必要的二次初始化。</p><p><strong>改进后的构造函数</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">SimpleClass::<span class="hljs-built_in">SimpleClass</span>() : <span class="hljs-built_in">myInt</span>(<span class="hljs-number">5</span>), <span class="hljs-built_in">myString</span>(<span class="hljs-string">&quot;C++!&quot;</span>), <span class="hljs-built_in">myVector</span>(<span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-comment">// 构造函数体现在可以为空</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用成员初始化列表：</p><ul><li>成员变量<code>myInt</code>、<code>myString</code>和<code>myVector</code>在构造函数体执行之前直接初始化为指定的值。</li><li>提高了构造过程的效率，尤其是对于类类型成员变量而言，避免了不必要的默认构造和后续赋值步骤。</li></ul><h3 id="使用初始化列表的必要场景">3.4 使用初始化列表的必要场景</h3><p>在C++中，某些情况下使用成员初始化列表不仅是提升效率的做法，而且是必须的。这主要包括以下两种情况：</p><ol type="1"><li><strong>初始化const成员变量</strong></li></ol><p>const成员变量一旦被定义，就必须立即初始化，而且之后不能再被修改。因此，必须在构造函数的初始化列表中对它们进行初始化。如果试图在构造函数体内赋值给const成员变量，编译器会报错。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Counter</span>(<span class="hljs-type">int</span> maxValue);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> maximum; <span class="hljs-comment">// const成员变量</span><br>&#125;;<br><br>Counter::<span class="hljs-built_in">Counter</span>(<span class="hljs-type">int</span> maxValue) : <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">maximum</span>(maxValue) &#123;<br>    <span class="hljs-comment">// 构造函数体可以为空，因为所有必要的初始化已在列表中完成</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>初始化没有默认构造函数的类类型成员</strong></li></ol><p>如果类的成员是另一个类的对象，且该类没有提供无参的默认构造函数（或者你需要调用一个特定的构造函数来初始化该成员），那么你必须通过初始化列表来初始化这些成员变量。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComplexObject</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ComplexObject</span>(<span class="hljs-type">int</span> param1, <span class="hljs-type">double</span> param2);<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">complexObj</span>(x, <span class="hljs-number">3.14</span>) &#123;<br>        <span class="hljs-comment">// 构造函数体内可进行其他初始化操作</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ComplexObject complexObj; <span class="hljs-comment">// 通过初始化列表调用特定构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在这些场景中，成员初始化列表是初始化成员变量的唯一方法。它确保了即使在复杂场景下，对象的构造也能正确、高效地完成。</p><h2 id="四使用static共享类信息">四、使用Static共享类信息</h2><h3 id="静态数据成员-static-data-members">4.1 静态数据成员 (Static Data Members)</h3><p>静态数据成员允许类的所有实例共享同一份数据。这意味着无论创建了多少个实例，静态成员只有一个副本。修改静态成员的状态将影响到所有实例。</p><p><strong>声明和定义</strong>：</p><ol type="1"><li><strong>声明</strong>：在类定义中声明静态成员，但不分配存储空间。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> myStaticData; <span class="hljs-comment">// 声明静态数据成员</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>定义</strong>：在类外部定义静态成员，并初始化其值。此步骤为静态成员分配存储空间。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> MyClass::myStaticData = <span class="hljs-number">137</span>; <span class="hljs-comment">// 定义并初始化静态数据成员</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：定义时使用类的全限定名（<code>MyClass::myStaticData</code>），并省略<code>static</code>关键字。</p><h3 id="静态成员函数">4.2 静态成员函数</h3><p>静态成员函数不依赖于类的实例，因此没有<code>this</code>指针。它们只能访问静态数据成员和其他静态成员函数。</p><p><strong>用法示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xLoc, <span class="hljs-type">int</span> yLoc); <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compareTwoPoints</span><span class="hljs-params">(<span class="hljs-type">const</span> Point &amp;one, <span class="hljs-type">const</span> Point &amp;two)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, y; <span class="hljs-comment">// 实例变量</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Point::compareTwoPoints</span><span class="hljs-params">(<span class="hljs-type">const</span> Point &amp;one, <span class="hljs-type">const</span> Point &amp;two)</span> </span>&#123;<br>    <span class="hljs-comment">// 静态成员函数实现</span><br>    <span class="hljs-keyword">return</span> one.x &lt; two.x || (one.x == two.x &amp;&amp; one.y &lt; two.y);<br>&#125;<br></code></pre></td></tr></table></figure><p>静态成员函数可以通过类名直接调用：<code>Point::compareTwoPoints(a, b);</code>。</p><h3 id="静态常量-static-const">4.3 静态常量 (static const)</h3><p>静态常量成员在所有实例间共享同一常量值，通常用于定义类级别的常量。</p><p><strong>声明和初始化</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassConstantExample</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 公开接口省略</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> MyConstant = <span class="hljs-number">137</span>; <span class="hljs-comment">// 声明并初始化静态常量</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这种初始化方式主要适用于整型常量。对于非整型的静态常量（如<code>double</code>或<code>float</code>），你可能需要在类外部进行定义。</p><h2 id="五-static_cast和const_cast">五、 <code>static_cast</code>和<code>const_cast</code></h2><p>在C++中，经常需要为类成员函数提供<code>const</code>和非<code>const</code>版本，以支持不同的使用场景。</p><p><code>std::vector</code>的<code>at()</code>函数就是一个典型例子，其中<code>const</code>版本返回元素的<code>const</code>引用，而非<code>const</code>版本则返回一个可修改的引用。为了减少代码冗余并保持逻辑一致性，可以利用<code>static_cast</code>和<code>const_cast</code>进行优雅的实现。</p><h3 id="static_cast">5.1 <code>static_cast</code></h3><ul><li><strong>用途</strong>：<code>static_cast</code>主要用于基本数据类型之间的转换，以及相关类类型之间的向上和向下转换，但不涉及运行时类型检查。</li><li><strong>特点</strong>：提供编译时类型安全检查，但不如<code>dynamic_cast</code>严格。</li></ul><h3 id="const_cast">5.2 <code>const_cast</code></h3><ul><li><strong>用途</strong>：<code>const_cast</code>专门用于修改类型的<code>const</code>或<code>volatile</code>属性，是实现<code>const</code>和非<code>const</code>成员函数共享实现的关键。</li><li><strong>特点</strong>：能够添加或去除对象的<code>const</code>性质，但使用时需要谨慎以避免未定义行为。</li></ul><h3 id="示例">5.3 示例</h3><p>假设有一个<code>Vector</code>类，我们希望共享<code>const</code>和非<code>const</code>版本的<code>at()</code>函数实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span></span>; <span class="hljs-comment">// 非const版本声明</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// const版本声明</span><br>&#125;;<br><br><span class="hljs-comment">// 非const版本的实现</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">Vector::at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// 首先将*this静态转换为const版本，然后调用const版本的at()</span><br>    <span class="hljs-comment">// 最后，使用const_cast去除返回值的const限定符</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> Vector*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">at</span>(index));<br>&#125;<br><br><span class="hljs-comment">// const版本的实现</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">Vector::at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-comment">// 进行边界检查等逻辑</span><br>    <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> data[index];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六示例代码">六、示例代码</h2><p><a href="/downloads/classes.zip">点击下载示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Class</tag>
      
      <tag>Const</tag>
      
      <tag>Static</tag>
      
      <tag>Cast</tag>
      
      <tag>Initialization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.Functions and Algorithms</title>
    <link href="/2024/02/06/5-Functions-and-Algorithms/"/>
    <url>/2024/02/06/5-Functions-and-Algorithms/</url>
    
    <content type="html"><![CDATA[<h2 id="概念提升">概念提升</h2><p>在上个笔记中，<code>countOccurences</code>函数还有最后一个问题没有解决：统计向量后半部分中最多有多少元素小于或等于5。这一问题可以使用<strong>谓词函数</strong>来解决。</p><p>谓词函数是一种特殊类型的函数，它接受一定数量的参数，并基于这些参数返回一个布尔值。这种函数特别适用于算法中的条件判断，能够增加代码的可复用性和灵活性。</p><p><strong>示例：谓词函数的类型</strong></p><ul><li>单参数谓词（Unary Predicate）：接受单一参数，返回布尔值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断是否等于3</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEqualTo3</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> val == <span class="hljs-number">3</span>; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>双参数谓词（Binary Predicate）：接受两个参数，返回布尔值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断第一个参数是否可被第二个参数整除</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDivisibleBy</span><span class="hljs-params">(<span class="hljs-type">int</span> dividend, <span class="hljs-type">int</span> divisor)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> dividend % divisor == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>应用于<code>countOccurences</code>函数</strong></p><p>通过将固定条件（如等于某个值）替换为谓词函数，我们可以将<code>countOccurences</code>函数改造为更加通用和灵活的版本。</p><p><strong>原始版本</strong>：统计元素等于给定值的次数。</p><p><strong>改进版本</strong>：统计满足任意谓词条件的元素次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InputIt, <span class="hljs-keyword">typename</span> UniPred&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countOccurences</span><span class="hljs-params">(InputIt begin, InputIt end, UniPred predicate)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = begin; iter != end; ++iter) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">predicate</span>(*iter))<br>            ++count;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实际应用</strong>：解决“统计向量后半部分中最多有多少元素小于或等于5”的问题。</p><ul><li>首先定义一个适当的谓词函数：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLessThanOrEqualTo5</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> val &lt;= <span class="hljs-number">5</span>; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>然后应用改进版的<code>countOccurences</code>函数：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">auto</span> mid = vec.<span class="hljs-built_in">begin</span>() + vec.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>; <span class="hljs-comment">// 计算中点</span><br><span class="hljs-type">int</span> count = <span class="hljs-built_in">countOccurences</span>(mid, vec.<span class="hljs-built_in">end</span>(), isLessThanOrEqualTo5);<br></code></pre></td></tr></table></figure><h2 id="lambda表达式">lambda表达式</h2><p>如果我们想让谓词函数更加通用，比如可以判断元素是否小于<strong>任意值</strong>，一种错误的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLessThanLimit</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> val &lt; limit;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-type">int</span> limit = <span class="hljs-number">8</span>;<br>    <br>    <span class="hljs-built_in">countOccurences</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), isLessThanLimit);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>isLessThanLimit</code>函数内的<code>limit</code>变量并不在其能访问的作用域。<strong>作用域</strong>阻碍谓词函数变得更通用。<strong>lambda 表达式</strong>则可以解决这一问题。</p><p>Lambda表达式允许你在需要函数对象的地方编写<strong>内联、匿名的函数体</strong>。这特别适用于定义<strong>短暂使用</strong>的自定义操作，如STL算法中的<strong>谓词函数</strong>。Lambda表达式可以捕获作用域中的变量，使其在函数体内可用，从而提高了代码的灵活性和表达力。</p><p><strong>示例：使用Lambda表达式比较元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 优化后的countOccurences函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InputIt, <span class="hljs-keyword">typename</span> UniPred&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countOccurences</span><span class="hljs-params">(InputIt begin, InputIt end, UniPred predicate)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = begin; iter != end; ++iter) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">predicate</span>(*iter)) &#123;<br>            ++count;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-type">int</span> limit = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">// 使用lambda表达式作为谓词函数</span><br>    <span class="hljs-keyword">auto</span> isLessThanLimit = [limit](<span class="hljs-keyword">auto</span> val) -&gt; <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> val &lt; limit;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">countOccurences</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), isLessThanLimit);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Elements less than &quot;</span> &lt;&lt; limit &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><h4 id="lambda表达式的优势">Lambda表达式的优势</h4><ul><li><strong>简洁性</strong>：Lambda表达式简化了代码，使其更加紧凑，尤其是当定义简短的函数时。</li><li><strong>灵活性</strong>：通过捕获列表，Lambda表达式可以访问函数外部的变量，无需通过参数传递。</li><li><strong>直观性</strong>：Lambda直接在需要的地方定义，提高了代码的可读性和理解度。</li></ul></blockquote><p><code>isLessThanLimit</code>的详细解释：</p><p><img src="image-20240205232016215.png" /></p><p><img src="image-20240205232105347.png" /></p><p><img src="image-20240205232219244.png" /></p><h3 id="stdfunction">std::function</h3><p><code>std::function</code> 是一个通用的函数封装器，用于存储和调用任何类型的可调用对象，如函数指针、Lambda表达式、或其他函数对象。</p><p>使用 <code>std::function&lt;R(Args...)&gt;</code>，你可以创建一个变量，该变量能够存储并调用返回类型为 <code>R</code>、接受参数类型为 <code>Args...</code> 的任何可调用对象。</p><p><strong>示例</strong></p><p>封装普通函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">/ 定义一个简单的加法函数<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 使用std::function封装一个函数指针</span><br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; addFunc = add;<br><br><span class="hljs-comment">// 使用std::function封装一个Lambda表达式</span><br>std::function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>)&gt; isPositive = [](<span class="hljs-type">int</span> val) &#123; <span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">0</span>; &#125;;<br><br><span class="hljs-comment">// 通过封装器调用函数</span><br><span class="hljs-type">int</span> result = <span class="hljs-built_in">func</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><h3 id="stdbind">std::bind</h3><p><code>std::bind</code> 允许调整函数参数的顺序，绑定一些参数为固定值，或者将成员函数绑定到对象实例上。它可以用来适配函数接口，使其满足特定的调用要求。</p><p><strong>示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> boundFunc = std::<span class="hljs-built_in">bind</span>(add, std::placeholders::_1, <span class="hljs-number">5</span>);<br><span class="hljs-type">int</span> result = <span class="hljs-built_in">boundFunc</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 等价于调用add(10, 5)</span><br></code></pre></td></tr></table></figure><p><code>std::bind</code> 的使用已经由C++11后的Lambda表达式大部分取代，因为Lambda提供了更加灵活和直观的方式来实现相同的功能。</p><h2 id="算法命名规范">算法命名规范</h2><p>C++ STL中的算法命名遵循特定的规范，以便于理解它们的功能和用法。这些命名规范包括后缀<code>_if</code>、<code>_copy</code>和<code>_n</code>，它们指示算法的特殊行为。</p><h3 id="后缀为_if的算法">后缀为<code>_if</code>的算法</h3><p>以<code>_if</code>结尾的算法（如<code>replace_if</code>、<code>count_if</code>等）要求传入一个谓词函数。这种类型的算法仅当元素满足谓词函数定义的条件时，才对元素执行指定操作。谓词函数接受一个元素作为参数，并返回一个布尔值，指示元素是否符合特定条件。</p><p><strong>示例：<code>count</code>与<code>count_if</code></strong></p><ul><li><code>count</code>算法计算一个特定值在给定范围内出现的次数：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; myVec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">137</span>, <span class="hljs-number">42</span>, <span class="hljs-number">137</span>, <span class="hljs-number">58</span>&#125;;<br>std::cout &lt;&lt; std::<span class="hljs-built_in">count</span>(myVec.<span class="hljs-built_in">begin</span>(), myVec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">137</span>) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><ul><li><code>count_if</code>算法根据谓词函数的条件，计算给定范围内元素满足条件的次数。例如，确定<code>vector&lt;int&gt;</code>中偶数的数量：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEven</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> value % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <br>&#125;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; myVec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>std::cout &lt;&lt; std::<span class="hljs-built_in">count_if</span>(myVec.<span class="hljs-built_in">begin</span>(), myVec.<span class="hljs-built_in">end</span>(), IsEven) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><h3 id="含copy的算法">含<code>copy</code>的算法</h3><p>包含<code>copy</code>字样的算法（如<code>remove_copy</code>、<code>partial_sort_copy</code>等）执行特定任务，并将结果复制到另一个容器。这类算法不修改原始数据，而是将变更后的数据集复制到新的位置。</p><h3 id="以_n结尾的算法">以<code>_n</code>结尾的算法</h3><p>以<code>_n</code>结尾的算法（如<code>generate_n</code>、<code>search_n</code>等）执行操作固定次数。这些算法通常需要一个起始迭代器和一个次数参数，表明操作执行的次数。</p><p><strong>示例：<code>fill</code>与<code>fill_n</code></strong></p><ul><li><code>fill</code>算法将一个范围内的所有元素设置为指定值：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">myDeque</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>std::<span class="hljs-built_in">fill</span>(myDeque.<span class="hljs-built_in">begin</span>(), myDeque.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li><code>fill_n</code>算法从给定起始位置开始，将指定数量的元素设置为某个值：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">fill_n</span>(myDeque.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">3</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h2 id="std-算法简介">std 算法简介</h2><h3 id="重排序算法">重排序算法</h3><p><strong>排序（sort）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">sort</span>(myVector.<span class="hljs-built_in">begin</span>(), myVector.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 按升序排序范围内的元素</span><br></code></pre></td></tr></table></figure><p><code>sort</code>函数要求传入的迭代器类型为随机访问迭代器，因此它不能用于对<code>map</code>或<code>set</code>这样的容器进行排序。</p><p>默认情况下，<code>sort</code>使用<code>&lt;</code>运算符对元素进行排序，但也可以指定一个自定义的比较函数或重载<code>&lt;</code>运算符来改变排序规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">placeT</span> &#123; <br>    <span class="hljs-type">int</span> x; <br>    <span class="hljs-type">int</span> y; <br>&#125;;<br><br>vector&lt;placeT&gt; myPlaceVector;<br><br><span class="hljs-comment">// 注意：比较函数可以按值传参，也可以接受const引用。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ComparePlaces</span><span class="hljs-params">(placeT one, placeT two)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (one.x != two.x)<br>        <span class="hljs-keyword">return</span> one.x &lt; two.x;<br>    <span class="hljs-keyword">return</span> one.y &lt; two.y;<br>&#125;<br><br><span class="hljs-built_in">sort</span>(myPlaceVector.<span class="hljs-built_in">begin</span>(), myPlaceVector.<span class="hljs-built_in">end</span>(), ComparePlaces);<br></code></pre></td></tr></table></figure><p><strong>随机打乱（random_shuffle）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">random_shuffle</span>(myVector.<span class="hljs-built_in">begin</span>(), myVector.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><p><code>random_shuffle</code>内部使用内置的<code>rand()</code>函数生成随机数。因此，在使用<code>random_shuffle</code>之前，应该先使用<code>srand</code>函数对随机数生成器进行种子设置。</p><p><strong>旋转（rotate）：</strong></p><p>旋转容器中的元素。例如，对于给定的输入容器<code>(0,1,2,3,4,5)</code>，围绕位置3旋转容器将得到<code>(2,3,4,5,0,1)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 它接受三个迭代器，分别是范围的开始、新的起始位置和结束。</span><br><span class="hljs-built_in">rotate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>, v.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h3 id="查找算法">查找算法</h3><p><strong>find：</strong></p><p><code>find</code>函数接收两个迭代器（定义一个范围）和一个值作为参数，返回一个指向范围内第一个等于该值的元素的迭代器。如果没有找到匹配的元素，<code>find</code>将返回第二个迭代器（即范围的末尾）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(myVector.<span class="hljs-built_in">begin</span>(), myVector.<span class="hljs-built_in">end</span>(), <span class="hljs-number">137</span>) != myVector.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-comment">// 如果向量中包含137</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>binary_search</strong></p><p>对于已排序的线性容器（如已排序的向量），可以使用<code>binary_search</code>算法快速搜索。该算法检查指定值是否存在于容器中，但不返回元素的迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 假设myVector已经排序</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">binary_search</span>(myVector.<span class="hljs-built_in">begin</span>(), myVector.<span class="hljs-built_in">end</span>(), <span class="hljs-number">137</span>)) &#123;<br>    <span class="hljs-comment">// 找到了137</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>lower_bound</strong></p><p><code>binary_search</code>只能用于检查元素是否存在，而<code>lower_bound</code>可用于获取具体元素位置的迭代器。</p><p>如果你想要执行二分查找并获取指向某个元素的迭代器，应使用<code>lower_bound</code>算法。<code>lower_bound</code>返回一个指向第一个不小于（大于或等于）指定值的元素的迭代器。如果范围内不存在这样的元素，则<code>lower_bound</code>返回的迭代器可能会指向一个与所查找元素不同的值。</p><h3 id="移除算法">移除算法</h3><p><strong><code>remove</code> 和 <code>remove_if</code></strong></p><p>C++标准库提供了<code>remove</code>和<code>remove_if</code>算法，用于从序列中移除元素。然而，这些算法并不直接从容器中删除元素；它们重新排列容器中的元素，将不需要删除的元素前移，然后返回新的逻辑序列结束的迭代器。实际的容器大小不变，被“移除”的元素仍在容器的末尾部分，只是不再是序列的一部分。</p><p><strong>使用<code>remove</code></strong></p><p><code>remove</code>算法移除所有等于指定值的元素。例如，从一个整数向量中移除所有的<code>3</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> newEnd = std::<span class="hljs-built_in">remove</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><span class="hljs-comment">// vec现在可能是&#123;0, 1, 2, 4, x, x&#125;，其中x是未定义的值</span><br></code></pre></td></tr></table></figure><p><strong>结合<code>erase</code>使用</strong></p><p>为了从容器中彻底删除这些元素，需要配合使用容器的<code>erase</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">vec.<span class="hljs-built_in">erase</span>(newEnd, vec.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// vec现在是&#123;0, 1, 2, 4&#125;</span><br></code></pre></td></tr></table></figure><p><strong>使用<code>remove_if</code></strong></p><p><code>remove_if</code>根据提供的谓词条件移除元素。这允许移除满足特定条件的所有元素，例如移除所有标点符号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string s = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-keyword">auto</span> newEnd = std::<span class="hljs-built_in">remove_if</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), ::ispunct);<br>s.<span class="hljs-built_in">erase</span>(newEnd, s.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// s现在是&quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><h2 id="迭代器适配器">迭代器适配器</h2><p>迭代器适配器允许我们以灵活的方式操作容器或其他序列，解决了在复制操作等场合预先确定目标空间大小的难题。它们表现得像迭代器，支持解引用和递增操作，但并不直接对应容器中的具体元素位置。</p><h3 id="插入迭代器">插入迭代器</h3><p>插入迭代器（如<code>back_insert_iterator</code>）在写入操作时不是替换容器中的元素，而是在容器的末尾插入新元素。这对于动态增长的容器，如<code>std::vector</code>或<code>std::deque</code>，特别有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; myVector;<br>std::back_insert_iterator&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">back_itr</span>(myVector);<br><br><span class="hljs-comment">// 使用循环填充vector</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    *back_itr = i;  <span class="hljs-comment">// 向myVector末尾插入值</span><br>    ++back_itr;<br>&#125;<br></code></pre></td></tr></table></figure><p>在算法中使用<code>std::back_inserter</code>可以简化代码，自动创建一个<code>back_insert_iterator</code>实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; original = <span class="hljs-comment">/* ... */</span><br>vector&lt;<span class="hljs-type">int</span>&gt; destination;<br>std::<span class="hljs-built_in">reverse_copy</span>(original.<span class="hljs-built_in">begin</span>(), original.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">back_inserter</span>(destination));<br></code></pre></td></tr></table></figure><h3 id="集合操作迭代器">集合操作迭代器</h3><p>对于集合操作，如求并集、交集等，<code>std::inserter</code>在指定位置插入新元素，适用于<code>std::set</code>等不支持<code>push_back</code>的容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::set&lt;<span class="hljs-type">int</span>&gt; setOne, setTwo, result;<br><span class="hljs-comment">// 填充setOne和setTwo</span><br>std::<span class="hljs-built_in">set_union</span>(setOne.<span class="hljs-built_in">begin</span>(), setOne.<span class="hljs-built_in">end</span>(), <br>               setTwo.<span class="hljs-built_in">begin</span>(), setTwo.<span class="hljs-built_in">end</span>(), <br>               std::<span class="hljs-built_in">inserter</span>(result, result.<span class="hljs-built_in">begin</span>()));<br></code></pre></td></tr></table></figure><h3 id="ostream_iterator"><code>ostream_iterator</code></h3><p><code>ostream_iterator</code>用于将输出操作关联到一个流（如标准输出<code>cout</code>或文件流<code>ofstream</code>），而不是直接操作容器中的元素。向<code>ostream_iterator</code>写入值时，这些值会被发送到关联的输出流。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 将整数值写入cout，每个值后跟一个空格</span><br><span class="hljs-function">std::ostream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">out_itr</span><span class="hljs-params">(std::cout, <span class="hljs-string">&quot; &quot;</span>)</span></span>;<br>*out_itr = <span class="hljs-number">137</span>;  <span class="hljs-comment">// 向cout打印 137</span><br>++out_itr;<br>*out_itr = <span class="hljs-number">42</span>;   <span class="hljs-comment">// 向cout打印 42</span><br></code></pre></td></tr></table></figure><p>使用<code>std::copy</code>与<code>ostream_iterator</code>结合，可以简洁地将容器中的元素输出到标准输出或文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; myVector = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>std::<span class="hljs-built_in">copy</span>(myVector.<span class="hljs-built_in">begin</span>(), myVector.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">ostream_iterator</span>&lt;<span class="hljs-type">int</span>&gt;(std::cout, <span class="hljs-string">&quot; &quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="istream_iterator"><code>istream_iterator</code></h3><p><code>istream_iterator</code>允许从输入流（如标准输入或文件流）读取值，将流视为元素序列。特殊的<code>istream_iterator</code>实例表示流的末尾。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::istream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">start</span><span class="hljs-params">(std::cin)</span>, end</span>; <span class="hljs-comment">// start从cin读取int，end表示流末尾</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(start, end)</span></span>; <span class="hljs-comment">// 从cin读取整数直到遇到非整数或EOF</span><br></code></pre></td></tr></table></figure><p>这种方式极大简化了从标准输入或文件中读取数据到容器的过程。</p><h2 id="练习">练习：</h2><p>实现一个高效通用的<code>remove_if</code>算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ForwardIt, <span class="hljs-keyword">typename</span> UniPred&gt;<br><span class="hljs-function">ForwardIt <span class="hljs-title">remove_if</span><span class="hljs-params">(ForwardIt first, ForwardIt last, UniPred pred)</span></span><br><span class="hljs-function"></span>&#123;<br>    ForwardIt result = first;  <span class="hljs-comment">// 用于记录满足条件的元素的位置</span><br><br>    <span class="hljs-comment">// 遍历范围 [first, last)</span><br>    <span class="hljs-keyword">for</span> (ForwardIt it = first; it != last; ++it) &#123;<br>        <span class="hljs-comment">// 如果当前元素满足条件，跳过它</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">pred</span>(*it)) &#123;<br>            *result = std::<span class="hljs-built_in">move</span>(*it);  <span class="hljs-comment">// 移动元素到满足条件的位置</span><br>            ++result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Functions</tag>
      
      <tag>Algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.Template Function</title>
    <link href="/2024/02/05/4-Template-Function/"/>
    <url>/2024/02/05/4-Template-Function/</url>
    
    <content type="html"><![CDATA[<h2 id="模板函数">模板函数</h2><p>一个通用的比较大小的函数：</p><p><img src="image-20240205174804348.png" /></p><p>调用这一函数：</p><ol type="1"><li>模板的显式实例化</li></ol><p><img src="image-20240205174828098.png" /></p><ol type="1"><li>隐式实例化</li></ol><p><img src="image-20240205174849968.png" /></p><p><img src="image-20240205174908899.png" /></p><p><img src="image-20240205174928361.png" /></p><h2 id="概念提升">概念提升</h2><p>在写模板函数时往往会对模板参数做出一定的假设，这些假设限制了所编写的模板函数的通用性。</p><p>尝试解除这些假设的限制，使得编写的模板的函数更通用。例如，对于<code>countOccurences</code>函数而言，能否解决以下问题：</p><p><img src="image-20240205165453225.png" /></p><p>以下展示逐渐放松<code>countOccurences</code>函数参数限制的过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// How many times does the integer [val] appear in an entire vector of integers?</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countOccurences</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); ++i) &#123; <br>        <span class="hljs-keyword">if</span> (vec[] == val) ++count; <br>    &#125; <br>    <span class="hljs-keyword">return</span> count; <br>&#125;<br><br><span class="hljs-comment">// How many times does the [type] [val] appear in an entire vector of [type]?</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> DataType&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countOccurences</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;DataType&gt;&amp; vec, </span></span><br><span class="hljs-params"><span class="hljs-function">                    DataType val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); ++i) &#123; <br>        <span class="hljs-keyword">if</span> (vec[] == val) ++count; <br>    &#125; <br>    <span class="hljs-keyword">return</span> count; <br>&#125;<br><br><span class="hljs-comment">// How many times does the [type] [val] appear in an entire [collection] of [type]?</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Collection, <span class="hljs-keyword">typename</span> DataType&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countOccurences</span><span class="hljs-params">(<span class="hljs-type">const</span> Collection&amp; list, </span></span><br><span class="hljs-params"><span class="hljs-function">                    DataType val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = list.<span class="hljs-built_in">begin</span>(); iter != list.<span class="hljs-built_in">end</span>(); ++iter) &#123; <br>        <span class="hljs-keyword">if</span> (*iter == val) ++count; <br>    &#125; <br>    <span class="hljs-keyword">return</span> count; <br>&#125;<br><br><span class="hljs-comment">// How many times does the [type] [val] appear in [a range of elements]?</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InputIt, <span class="hljs-keyword">typename</span> DataType&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countOccurences</span><span class="hljs-params">(InputIt begin, InputIt end, </span></span><br><span class="hljs-params"><span class="hljs-function">                    DataType val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = begin; iter != end; ++iter) &#123; <br>        <span class="hljs-keyword">if</span> (*iter == val) ++count; <br>    &#125; <br>    <span class="hljs-keyword">return</span> count; <br>&#125;<br></code></pre></td></tr></table></figure><p>但最后版本的<code>countOccurences</code>仍未能解决最后一个问题：统计向量后半部分中最多有多少元素小于或等于5。在后面，我们会使用<strong>谓词函数</strong>来解决这一问题。</p><h2 id="隐式接口">隐式接口</h2><p>编译器会将每个模板参数替换为实例化它的任何参数。</p><p>例如，对最后一个版本的<code>countOccurences</code>函数而言：</p><p><img src="image-20240205165904004.png" /></p><p>按照上述实参，将模板参数替换后会出现语法错误：</p><p><img src="image-20240205165941336.png" /></p><p>实际上，模板函数定义了每个模板形参必须满足的<strong>隐式接口</strong>。如果实例化类型不支持这些，则会出现严重的编译错误。</p><p>例如，上述<code>countOccurences</code>函数就有以下隐式接口：</p><ul><li><code>InputIt</code>必须支持：<ul><li>copy assignment (<code>iter = begin</code>)</li><li>prefix operator (<code>++iter</code>)</li><li>comparable to end (<code>begin != end</code>)</li><li>dereference operator (<code>*iter</code>)</li></ul></li><li><code>DataType</code>必须支持：<ul><li>comparable to <code>*iter</code></li></ul></li></ul><h2 id="overload-resolution">overload resolution</h2><h3 id="模板函数重载解析">模板函数重载解析</h3><p>当存在多个模板函数候选时，C++通过overload resolution来确定使用哪个模板。这个过程主要包括三个步骤：</p><p><img src="image-20240205171142915.png" /></p><p>其中，在第二步substitution的过程中：</p><ul><li>编译器尝试用实参类型替换模板函数的模板参数。如果实参类型不满足模板要求的条件（即不符合隐式接口），该模板实例不被生成。</li><li><strong>SFINAE</strong>（Substitution Failure Is Not An Error）：如果替换失败（实参类型不符合隐式接口），这不会导致编译错误。相反，失败的模板重载会被排除出候选函数集。</li><li><strong>作用</strong>：通过SFINAE，可以设计只在满足特定条件时参与重载解析的模板函数，增加类型的条件选择灵活性。</li></ul><h3 id="后置返回类型">后置返回类型</h3><p>C++11特性，允许将返回类型放在函数参数列表后，通过<code>-&gt;</code>指定。特别适用于模板函数和需要参数类型推断的复杂函数。</p><h4 id="示例">示例</h4><ul><li><strong>函数模板</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a + b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Lambda表达式</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="利用sfinae">利用SFINAE</h4><p>使用后置返回类型可以利用SFINAE的特性，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/* 1.如果T有size()成员函数，则替换成功。 */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">printSize</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;a)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a.size())</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; “printing with size member function : ”;<br>    cout &lt;&lt; a.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-comment">/* 2.如果T能被取反，则替换成功。 */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">printSize</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;a)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(-a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; “printing with negative numeric function : ”;<br>    cout &lt;&lt; -a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> -a;<br>&#125;<br><br><span class="hljs-comment">/* 3.如果T是指针，且指向的对象有size()成员函数，则替换成功。 */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">printSize</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;a)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a-&gt;size())</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; “printing with pointer function : ”;<br>    cout &lt;&lt; a-&gt;<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> a-&gt;<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-built_in">printSize</span>(vec);     <span class="hljs-comment">// calls first overload</span><br>    <span class="hljs-built_in">printSize</span>(vec[]);  <span class="hljs-comment">// calls second overload</span><br>    <span class="hljs-built_in">printSize</span>(&amp;vec);    <span class="hljs-comment">// calls third overload</span><br>    <span class="hljs-built_in">printSize</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// compiler error</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="练习">练习</h2><p>修改以下函数，使其变得更通用：</p><ol type="1"><li>原函数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">tuple&lt;<span class="hljs-type">bool</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; </span><br><span class="hljs-function">    <span class="hljs-title">mismatch</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;vec1, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;vec2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; vec1.<span class="hljs-built_in">size</span>() &amp;&amp; vec1[] == vec2[]) &#123;<br>        ++i;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == vec1.<span class="hljs-built_in">size</span>())<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">true</span>, vec1[], vec2[]&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>提升后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InputIt1, <span class="hljs-keyword">typename</span> InputIt2&gt;<br><span class="hljs-function">pair&lt;InputIt1, InputIt2&gt; <span class="hljs-title">mismatch</span><span class="hljs-params">(InputIt1 first1, InputIt1 last1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  InputIt2 first2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (first1 != last1 &amp;&amp; *first1 == *first2) &#123;<br>        ++first1;<br>        ++first2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;first1, first2&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例代码">示例代码</h2><p><a href="/downloads/template_functions.zip">点击下载示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Templates</tag>
      
      <tag>Function Template</tag>
      
      <tag>SFINE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.STL Associative Containers and Iterators</title>
    <link href="/2024/02/03/3-STL-Associative-Containers-and-Iterators/"/>
    <url>/2024/02/03/3-STL-Associative-Containers-and-Iterators/</url>
    
    <content type="html"><![CDATA[<h2 id="associative-containers">Associative Containers</h2><ul><li>没有顺序的概念</li><li>使用key而非index访问数据。</li><li>包括以下四种：<ul><li><code>std::map&lt;T1,T2&gt;</code></li><li><code>std::set&lt;T&gt;</code></li><li><code>std::unordered_map&lt;T1,T2&gt;</code></li><li><code>std::unordered_set&lt;T&gt;</code></li></ul></li></ul><p>其中，<code>std::map&lt;T1,T2&gt;</code>和<code>std::set&lt;T&gt;</code>的key需要能够使用<code>&lt;</code>来比较大小。</p><p><code>std::unordered_map&lt;T1,T2&gt;</code>和<code>std::unordered_set&lt;T&gt;</code>则基于哈希，需要定义key的哈希函数。</p><h2 id="map">map</h2><p>map支持的几种操作：</p><ul><li>插入k-v对</li><li>删除k-v对</li><li>检查一个特定的<code>key</code>是否存在</li><li>给定key，查询对应的value</li></ul><h3 id="插入k-v对">插入k-v对</h3><ol type="1"><li>使用方括号向map中插入k-v对：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;string, <span class="hljs-type">int</span>&gt; numberMap;<br><span class="hljs-comment">// Indexing into a map into a nonexistent key implicitly creates a key/value pair.</span><br>numberMap[<span class="hljs-string">&quot;zero&quot;</span>] = <span class="hljs-number">0</span>; <br>numberMap[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-number">1</span>;<br>numberMap[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>使用<code>insert</code>插入k-v对</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;string, <span class="hljs-type">int</span>&gt; numberMap;<br>numberMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-number">0</span>));<br>numberMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-number">1</span>));<br>numberMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>使用<code>insert</code>和<code>[]</code>的区别：</p><p>如果尝试使用<code>insert</code>函数将k-v对插入到map中，而该key已经存在，则map将不会插入k-v对，也不会更新与现有key关联的value。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Populate a map using [ ] */</span><br>map&lt;string, string&gt; one;<br>one[<span class="hljs-string">&quot;C++&quot;</span>] = <span class="hljs-string">&quot;sad&quot;</span>;<br>one[<span class="hljs-string">&quot;C++&quot;</span>] = <span class="hljs-string">&quot;happy&quot;</span>;  <span class="hljs-comment">// one[&quot;C++&quot;] == &quot;happy&quot;</span><br><br><span class="hljs-comment">/* Populate a map using insert */</span><br>map&lt;string, string&gt; two;<br>two.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;sad&quot;</span>));<br>two.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;happy&quot;</span>)); <span class="hljs-comment">// one[&quot;C++&quot;] == &quot;sad&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>map的insert函数返回一个类型为<code>&lt;iterator, bool&gt;</code>的pair值。</p><p>pair中的bool值表示插入操作是否成功。结果为true表示k-v对已添加，结果为false表示key已经存在。</p><p>pair中迭代器指向映射中的k-v对。如果k-v对是新添加的，则该迭代器指向新插入的k-v对；如果k-v对已经存在，则迭代器指向阻止操作的现有k-v对。</p><p>因此，可以这样使用<code>insert</code>插入k-v对：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Try to insert normally. */</span><br>pair&lt;map&lt;string, <span class="hljs-type">int</span>&gt;::iterator, <span class="hljs-type">bool</span>&gt; result = myMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;STL&quot;</span>, <span class="hljs-number">137</span>));<br><span class="hljs-comment">/* If insertion failed, manually set the value. */</span><br><span class="hljs-keyword">if</span> (!result.second)<br>    result.first-&gt;second = <span class="hljs-number">137</span>;<br></code></pre></td></tr></table></figure></blockquote><h3 id="删除k-v对">删除k-v对</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">myMap.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;key&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="检查特定的key是否存在">检查特定的<code>key</code>是否存在</h3><ol type="1"><li>使用<code>count</code>成员函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (myMap.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) <br>    cout &lt;&lt; “Not Found”;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>使用<code>std::find()</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(myMap.<span class="hljs-built_in">begin</span>(), myMap.<span class="hljs-built_in">end</span>(), key) == myMap.<span class="hljs-built_in">end</span>())<br>    cout &lt;&lt; “Not Found”;<br></code></pre></td></tr></table></figure><blockquote><p>count实际上只是对find函数的调用。所以find稍微快一点。</p></blockquote><h3 id="给定key查询对应的value">给定key，查询对应的value</h3><ol type="1"><li>使用<code>[]</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; numberMap[<span class="hljs-string">&quot;xyzzy&quot;</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>使用<code>.at</code>成员函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; myMap.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><blockquote><p><strong>两者的区别：</strong></p><p>若给定的<code>key</code>不存在，<code>[]</code>则会隐式的创建k-v对，以给定key为键，值为默认值。</p><p>若给定的<code>key</code>不存在，使用<code>.at</code>查询时则会报错。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::map&lt;<span class="hljs-type">int</span>, std::string&gt; myMap;<br>myMap[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;One&quot;</span>;<br>cout &lt;&lt; myMap.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) &lt;&lt; endl; <span class="hljs-comment">// 输出： &quot;one&quot;</span><br>cout &lt;&lt; myMap.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>) &lt;&lt; endl; <span class="hljs-comment">// 抛出 std::out_of_range 异常</span><br>cout &lt;&lt; myMap[<span class="hljs-number">2</span>] &lt;&lt; endl;    <span class="hljs-comment">// 输出空字符串</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="set">Set</h2><ul><li>set是没有value的map的一种特殊情况。<ul><li>对应的value为true（若key存在），为false（若key不存在）。</li></ul></li></ul><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">set&lt;<span class="hljs-type">int</span>&gt; mySet;<br>mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">137</span>); <span class="hljs-comment">// Now contains: 137</span><br>mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// Now contains: 42 137</span><br>mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">137</span>); <span class="hljs-comment">// Now contains: 42 137,没有改变集合的内容。集合不允许重复元素。</span><br><br><span class="hljs-keyword">if</span> (mySet.<span class="hljs-built_in">count</span>(<span class="hljs-number">137</span>)) <span class="hljs-comment">//.count用于检查元素是否存在于集合中</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;137 is in the set.&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// Printed</span><br><span class="hljs-keyword">if</span> (!mySet.<span class="hljs-built_in">count</span>(<span class="hljs-number">500</span>))<br>    cout &lt;&lt; <span class="hljs-string">&quot;500 is not in the set.&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// Printed</span><br>    <br>mySet.<span class="hljs-built_in">erase</span>(<span class="hljs-number">137</span>); <span class="hljs-comment">// Removes 137, if it exists.</span><br></code></pre></td></tr></table></figure><h2 id="iterator">Iterator</h2><p>每个容器以不同的格式存储其数据，迭代器为访问存储在容器中的数据提供了一种干净、一致的机制，而不管这些数据是如何存储的。</p><p>Every STL container class exports a member function <code>begin()</code> which yields an iterator pointing to <strong>the first element of that container</strong>.</p><p>Each STL container exports a special function called <code>end()</code> that returns an iterator to <strong>the element one past the end of the container</strong>.</p><p><img src="iterator.png" /></p><p>使用迭代器遍历容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; myVector = <span class="hljs-comment">/* ... some initialization ... */</span> <br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator itr = myVector.<span class="hljs-built_in">begin</span>(); <br>     itr != myVector.<span class="hljs-built_in">end</span>(); ++itr)<br>    cout &lt;&lt; *itr &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>迭代器的美妙之处在于它们可以在任何STL容器上工作，包括set。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">set&lt;<span class="hljs-type">int</span>&gt; mySet = <span class="hljs-comment">/* ... some initialization ... */</span><br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator itr = mySet.<span class="hljs-built_in">begin</span>(); <br>     itr != mySet.<span class="hljs-built_in">end</span>(); ++itr)<br>    cout &lt;&lt; *itr &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>迭代器的用法不止有遍历元素。例如：</p><p><strong>排序</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><p><strong>搜索：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> elemToFind = <span class="hljs-number">5</span>; <br>vector::iterator it = std::<span class="hljs-built_in">find</span>(vec.<span class="hljs-built_in">begin</span>(),  vec.<span class="hljs-built_in">end</span>(), elemToFind);<br><span class="hljs-keyword">if</span>(it != vec.<span class="hljs-built_in">end</span>()) &#123; <br>    cout &lt;&lt; <span class="hljs-string">&quot;Found: &quot;</span> &lt;&lt; *it &lt;&lt; endl; <br>&#125; <span class="hljs-keyword">else</span> &#123; <br>    cout &lt;&lt; <span class="hljs-string">&quot;Element not found!&quot;</span> &lt;&lt; endl; <br>&#125; <br></code></pre></td></tr></table></figure><p><strong>确定范围：</strong></p><p>单个迭代器指向容器类中的单个位置，并表示间接读取或写入该值的方法。</p><p>一对迭代器定义了两个位置，从而定义了一个元素范围。</p><p>set中提供了两个成员函数：</p><ul><li><code>lower_bound</code>：接受一个值，然后返回一个迭代器，指向集合中第一个大于或等于该值的元素。</li><li><code>upper_bound</code>：接受一个值，返回一个迭代器，指向集合中第一个严格大于该值的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// iterates over all elements in the set in the range [10, 100]</span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator stop = mySet.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator itr = mySet.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">10</span>); itr != stop; ++itr)<br>    <span class="hljs-comment">/* ... perform tasks... */</span><br></code></pre></td></tr></table></figure><p><img src="iterator-range.png" /></p><p>range based for loop的本质就是使用迭代器访问的简写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// range based for loop</span><br>map&lt;string, <span class="hljs-type">int</span>&gt; myMap;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> thing : myMap) &#123;<br>    <span class="hljs-built_in">doSomething</span>(thing.first, thing.second);<br>&#125;<br><br><span class="hljs-comment">// 本质：</span><br>map&lt;string, <span class="hljs-type">int</span>&gt; myMap;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter = myMap.<span class="hljs-built_in">begin</span>(); iter != myMap.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>    <span class="hljs-keyword">auto</span> thing = *iter;<br>    <span class="hljs-built_in">doSomething</span>(thing.first, thing.second);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="map-iterators">Map Iterators</h2><ul><li>map的迭代器略有不同，因为map同时拥有key和value。</li><li>如果解引用一个<code>map&lt;KeyType, ValueType&gt;</code>的迭代器，会得到一个类型为<code>pair&lt;const KeyType, ValueType&gt;</code>的pair</li></ul><p>先看看<code>pair</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">pair&lt;<span class="hljs-type">int</span>, string&gt; myPair;<br>myPair.first = <span class="hljs-number">137</span>; <br>myPair.second = <span class="hljs-string">&quot;C++ is awesome!&quot;</span>;<br><br>pair&lt;<span class="hljs-type">int</span>, string&gt; myPair = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">137</span>, <span class="hljs-string">&quot;string!&quot;</span>);  <span class="hljs-comment">// create a pair on-the-fly</span><br></code></pre></td></tr></table></figure><p>map迭代器的使用举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator i = m.<span class="hljs-built_in">begin</span>();<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator end = m.<span class="hljs-built_in">end</span>();<br><span class="hljs-keyword">while</span>(i != end) &#123;<br>    cout &lt;&lt; (*i).first &lt;&lt; (*i).second &lt;&lt; endl;<br>    ++i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="iterator-types">Iterator Types</h2><p>一些看似很合理的使用迭代器的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::vector <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <br><span class="hljs-keyword">auto</span> mid = v.<span class="hljs-built_in">begin</span>() + v.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>;<br><br><span class="hljs-function">std::deque <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">13</span>)</span></span>; <br><span class="hljs-keyword">auto</span> some_iter = d.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>但如果对<code>std::list</code>（双向链表）执行上述操作就会报错：</p><p><img src="list-iterator-error.png" /></p><p>这是由迭代器的类型导致的。</p><p>迭代器有5种类型：</p><p><img src="iterator-type.png" /></p><p>所有类型的迭代器都有一些共同的特征:</p><ul><li>可以从已有的迭代器中创建</li><li>可以使用++</li><li>可以使用==和!=比较</li></ul><p>其余特征则取决于迭代器的类型：</p><p><img src="iterator-type-1.png" /></p><p><strong>Input Iterators</strong></p><p>只读，即只能在表达式的右侧解引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; v = ... <br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itr = v.<span class="hljs-built_in">begin</span>(); <br><span class="hljs-type">int</span> val = *itr; <br>*itr = <span class="hljs-number">12</span>; <span class="hljs-comment">// 错误！</span><br></code></pre></td></tr></table></figure><p><strong>Output Iterators</strong></p><p>只能写，即只能在表达式的左侧解引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; v = ... <br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itr = v.<span class="hljs-built_in">begin</span>(); <br>*itr = <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> val = *itr;  <span class="hljs-comment">// 错误！！</span><br></code></pre></td></tr></table></figure><p><strong>Forward Iterators</strong></p><p>可以读写以及++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; v = ... <br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itr = v.<span class="hljs-built_in">begin</span>(); <br>*itr = <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> val = *itr; <br></code></pre></td></tr></table></figure><p><strong>Bidirectional Iterators</strong></p><p>与Forward Iterators相同且可以--</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; v = ... <br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itr = v.<span class="hljs-built_in">begin</span>(); <br>++itr; <br><span class="hljs-type">int</span> val = *itr; <br>--itr; <br><span class="hljs-type">int</span> val2 = *itr; <br></code></pre></td></tr></table></figure><p><strong>Random Access Iterators</strong></p><p>和Bidirectional Iterators相同且可以使用+和-任意递增或递减</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; v = ... <br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itr = v.<span class="hljs-built_in">begin</span>(); <br>itr += <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> val = *itr; <br></code></pre></td></tr></table></figure><h2 id="invalidated-iterators">invalidated iterators</h2><p><img src="iterator-invalidate-1.png" /></p><p><strong>例1：</strong></p><p><img src="iterator-invalidate-2.png" /></p><p>修改后：</p><p><img src="iterator-invalidate-3.png" /></p><p>例2：</p><p><img src="iterator-invalidate-4.png" /></p><p>修改：</p><p><img src="iterator-invalidate-5.png" /></p><h2 id="multicontainers">Multicontainers</h2><p><code>multimap</code>：一个key可以有多个不同的value。</p><p><code>multiset</code>：可以包含多个key。</p><p>与普通版本的区别：</p><ul><li><code>count</code>函数将返回容器中元素的实际数量，而不仅仅是二进制0或1。</li><li><code>find</code>函数仍然会返回迭代器，但它所指向的元素不能保证是该元素在容器中的唯一副本。</li><li><code>erase</code>将擦除指定键或元素的所有副本。</li><li>在<code>multimap</code>中不存在方括号，需要使用<code>insert</code>函数插入k-v对</li><li><code>equal_range</code>，返回一对<code>&lt;iterator, iterator&gt;</code>对象，表示容器中等于指定值的成员的范围，例如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">multimap&lt;string, <span class="hljs-type">int</span>&gt; myMultiMap;<br><span class="hljs-comment">/* Store the result of the equal_range */</span><br>pair&lt;multimap&lt;string, <span class="hljs-type">int</span>&gt;::iterator, multimap&lt;string, <span class="hljs-type">int</span>&gt;::iterator&gt;<br>    myPair = myMultiMap.<span class="hljs-built_in">equal_range</span>(<span class="hljs-string">&quot;STL&quot;</span>);<br><span class="hljs-comment">/* Iterate over it! */</span><br>multimap&lt;string, <span class="hljs-type">int</span>&gt;::iterator itr;<br><span class="hljs-keyword">for</span>(itr = myPair.first; itr != myPair.second; ++itr)<br>   cout &lt;&lt; itr-&gt;first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; itr-&gt;second &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>多容器在实践中相当少见，部分原因是它们可以很容易地使用其他方法来模拟。</p><p>例如，<code>multimap&lt;string, int&gt;</code>的行为类似于<code>map&lt;string, vector&lt;int&gt; &gt;</code>，因为两者都是将字符串映射到一定数量的<code>int</code>。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
      <tag>Map</tag>
      
      <tag>Set</tag>
      
      <tag>Multimap</tag>
      
      <tag>Multiset</tag>
      
      <tag>Iterator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.STL Sequence Containers</title>
    <link href="/2024/02/02/2-STL-Sequence-Containers/"/>
    <url>/2024/02/02/2-STL-Sequence-Containers/</url>
    
    <content type="html"><![CDATA[<h2 id="vector">vector</h2><h3 id="初始化">初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">myVector</span><span class="hljs-params">(<span class="hljs-number">15</span>)</span></span>;       <span class="hljs-comment">//初始大小为15，其中值均为0</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">myStringVector</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//初始大小为10，其中均为空字符串</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">myReals</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">137.0</span>)</span></span>; <span class="hljs-comment">//初始大小为20，值均为137.0</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">myStrings</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;(none)&quot;</span>)</span></span>; <span class="hljs-comment">//初始大小为5，值均为&quot;(none)&quot;</span><br><br>vector&lt;<span class="hljs-type">double</span>&gt; myReals;<br><span class="hljs-built_in">myReals</span>(<span class="hljs-number">20</span>, <span class="hljs-number">137.0</span>); <span class="hljs-comment">// Error: Only legal to do this when the object is created</span><br></code></pre></td></tr></table></figure><h3 id="添加元素">添加元素</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">push_back、<span class="hljs-keyword">insert</span><br>v.<span class="hljs-keyword">insert</span>(v.<span class="hljs-keyword">begin</span>() + n, <span class="hljs-built_in">e</span>);<br></code></pre></td></tr></table></figure><h3 id="resize">resize</h3><p><code>resize</code>可以在创建vector之后更改vector中的元素数量。</p><p>resize函数的语法与构造语法类似，可以指定多个元素，也可以指定多个元素和一个值，然后将调整vector的大小以容纳这么多元素。</p><p>但是，resize的行为与之前的构造有所不同，因为在使用resize时，vector可能已经包含元素。</p><p>resize的工作原理是从vector的末尾添加或删除元素，直到达到所需的大小。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; myVector; <span class="hljs-comment">// Defaults to empty vector</span><br><span class="hljs-built_in">PrintVector</span>(myVector); <span class="hljs-comment">// Output: [nothing]</span><br><br>myVector.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// Grow the vector, setting new elements to 0</span><br><span class="hljs-built_in">PrintVector</span>(myVector); <span class="hljs-comment">// Output: 0 0 0 0 0 0 0 0 0 0</span><br><br>myVector.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// Shrink the vector</span><br><span class="hljs-built_in">PrintVector</span>(myVector); <span class="hljs-comment">// Output: 0 0 0 0 0</span><br><br>myVector.<span class="hljs-built_in">resize</span>(<span class="hljs-number">7</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Grow the vector, setting new elements to 1</span><br><span class="hljs-built_in">PrintVector</span>(myVector); <span class="hljs-comment">// Output: 0 0 0 0 0 1 1</span><br><br>myVector.<span class="hljs-built_in">resize</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>); <span class="hljs-comment">// The second parameter is effectively ignored.</span><br><span class="hljs-built_in">PrintVector</span>(myVector); <span class="hljs-comment">// Output: 0</span><br></code></pre></td></tr></table></figure><h3 id="删除元素">删除元素</h3><p><code>pop_back</code>：从vector序列中移除最后一个元素</p><p><code>erase</code>：从vector中移除特定位置的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">myVector.<span class="hljs-built_in">erase</span>(myVector.<span class="hljs-built_in">begin</span>() + n); <span class="hljs-comment">// n represents the index of the element to erase</span><br><br>myVector.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//清除全部内容</span><br></code></pre></td></tr></table></figure><p><img src="vector-comparison.PNG" /></p><h2 id="deque">Deque</h2><p>vector只能高效的在一个方向上增长</p><p><img src="deque.png" /></p><p><img src="syntax-deque.png" /></p><p>如果deque比vector有更多的功能，为什么要使用vector?</p><p>主要原因是速度。这主要是因为两者实现方式的不同。</p><p><img src="comparison-vector-deque.png" /></p><h2 id="container-adaptors">Container adaptors</h2><p><img src="container-adaptors-1.png" /></p><p><img src="container-adaptors-2.png" /></p><p><img src="container-adaptors-3.png" /></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
      <tag>Vector</tag>
      
      <tag>Deque</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.Streams</title>
    <link href="/2024/02/02/1-Streams/"/>
    <url>/2024/02/02/1-Streams/</url>
    
    <content type="html"><![CDATA[<h2 id="cincout">cin,cout</h2><ol type="1"><li><p><strong>何时提示用户输入？</strong></p><p>当位置指针达到文件结尾（EOF）并且超过了缓冲区中的最后一个标记时，程序会挂起并等待用户输入。</p></li><li><p><strong>为什么</strong> <strong>cout</strong> <strong>操作不会立即将输出打印到控制台？输出什么时候才会被打印？</strong></p><p>因为 cout 的输出只是输出到了缓冲区，需要对缓冲区进行刷新才会打印到控制台。</p><p>输出刷新的三种情况：</p><ol type="1"><li>使用 <code>cout &lt;&lt; endl;</code></li><li>使用 <code>cout &lt;&lt; flush;</code></li><li>当 cin 正在等待用户输入时。</li></ol></li><li><p><strong>在 &gt;&gt; 操作中，位置指针是在 token 前还是 token 后跳过空白字符？位置指针是否总是读取到空白字符？如果不是，请提供一个反例。</strong></p><p>位置指针执行以下操作：</p><ol type="1"><li>在读取前跳过所有空白字符（空格、换行符等）。</li><li>读取字符，直到满足以下条件之一：<ul><li>遇到空白字符</li><li>对于原始数据类型，读取足够多的字符以形成有效的变量</li></ul></li><li>例如：如果从字符串 "86.2" 中提取一个整数，将得到 86，位置指针停在小数点之后。</li></ol></li></ol><h2 id="读写文件">读写文件</h2><h3 id="头文件和类型">头文件和类型</h3><ul><li>头文件：<code>&lt;fstream&gt;</code></li><li>类型：<ul><li><code>ifstream</code>：用于从文件读取。</li><li><code>ofstream</code>：用于向文件写入。</li><li><code>fstream</code>：可用于读写。</li></ul></li></ul><h3 id="创建和使用流">创建和使用流</h3><ul><li>创建 <code>ifstream</code> 实例：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ifstream <span class="hljs-title">myStream</span><span class="hljs-params">(<span class="hljs-string">&quot;myFile.txt&quot;</span>)</span></span>;<br><span class="hljs-type">int</span> myInteger;<br>myStream &gt;&gt; myInteger; <span class="hljs-comment">// 从 myFile.txt 中读取一个整数</span><br></code></pre></td></tr></table></figure><ul><li>使用 <code>open</code> 方法打开文件：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">ifstream myStream; <span class="hljs-comment">// 注意：没有指定文件</span><br>myStream.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;myFile.txt&quot;</span>); <span class="hljs-comment">// 现在从 myFile.txt 中读取</span><br></code></pre></td></tr></table></figure><h3 id="文件打开检查">文件打开检查</h3><ul><li>检查文件是否成功打开：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ifstream <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-string">&quot;myfile.txt&quot;</span>)</span></span>;<br><span class="hljs-keyword">if</span> (!input.<span class="hljs-built_in">is_open</span>())<br>    cerr &lt;&lt; <span class="hljs-string">&quot;无法打开文件 myfile.txt&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><ul><li>使用 <code>ofstream</code> 写入不存在的文件时，会创建新文件；若文件已存在，则覆盖内容。</li><li>由于 <code>open</code> 函数较早，因此使用 C++ 字符串时，需将其转换为 C 风格字符串（<code>.c_str()</code>）。</li></ul><h2 id="流操纵符stream-manipulators">流操纵符（Stream Manipulators）</h2><h3 id="头文件和常用操纵符">头文件和常用操纵符</h3><ul><li>头文件：<code>&lt;iomanip&gt;</code></li><li><code>setw</code>：设置输出宽度。</li><li><code>setfill</code>：设置填充字符。</li></ul><h3 id="示例">示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-number">137</span> &lt;&lt; endl; <span class="hljs-comment">// 设置宽度为10</span><br>cout &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>) &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-number">1000</span> &lt;&lt; endl; <span class="hljs-comment">// 使用 &#x27;0&#x27; 填充</span><br></code></pre></td></tr></table></figure><h3 id="其他流操纵符">其他流操纵符</h3><ul><li><code>boolalpha</code>：布尔值的文字输出。</li><li><code>hex</code>, <code>dec</code>, <code>oct</code>：设置数值的输出进制。</li></ul><h2 id="处理流错误">处理流错误</h2><ul><li>流错误可能发生在类型不匹配或读取失败的情况下。</li><li>流错误会使后续操作失败。</li></ul><h3 id="检查错误状态">检查错误状态</h3><ul><li>使用 <code>.fail()</code> 检查流的错误状态。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintTableBody</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-string">&quot;table-data.txt&quot;</span>)</span></span>; <span class="hljs-comment">/* 遍历文件中的行并读取数据。 */</span><br>    <span class="hljs-type">int</span> rowNumber = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> intValue;<br>        <span class="hljs-type">double</span> doubleValue;<br>        input &gt;&gt; intValue &gt;&gt; doubleValue;<br>        <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">fail</span>())<br>            <span class="hljs-keyword">break</span>;<br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(COLUMN_WIDTH) &lt;&lt; (rowNumber + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot; | &quot;</span>;<br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(COLUMN_WIDTH) &lt;&lt; intValue &lt;&lt; <span class="hljs-string">&quot; | &quot;</span>;<br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(COLUMN_WIDTH) &lt;&lt; doubleValue &lt;&lt; endl;<br>        rowNumber++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的 <code>while (true)</code> 写法有些复杂，可以使用以下形式进行简化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> intValue;<br><span class="hljs-type">double</span> doubleValue;<br><span class="hljs-keyword">while</span> (input &gt;&gt; intValue &gt;&gt; doubleValue) &#123; <br>    <span class="hljs-comment">/* ... 处理值 ... */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cin和导致的错误">cin和&gt;&gt;导致的错误</h2><h3 id="常见问题">常见问题</h3><ul><li><code>cin</code> 读取整行数据但仅提取空白分隔的标记。</li><li>缓冲区中的残留数据可能导致 <code>cin</code> 在错误的时机等待输入。</li><li><code>cin</code> 失败后，所有后续操作也会失败。</li></ul><h3 id="示例和问题解释">示例和问题解释</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> age;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入您的年龄：&quot;</span>;<br>cin &gt;&gt; age; <span class="hljs-comment">// 输入 &quot;2.71828&quot;，age 为 2</span><br>string password;<br>cout &lt;&lt; <span class="hljs-string">&quot;输入管理员密码：&quot;</span>;<br>cin &gt;&gt; password; <span class="hljs-comment">// 如果输入为 &quot;password y&quot;，将自动读取 &#x27;y&#x27;</span><br><span class="hljs-keyword">if</span> (password == <span class="hljs-string">&quot;password&quot;</span>) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;是否要擦除硬盘（y 或 n）？&quot;</span>;<br>    <span class="hljs-type">char</span> yesOrNo;<br>    cin &gt;&gt; yesOrNo;<br>    <span class="hljs-keyword">if</span> (yesOrNo == <span class="hljs-string">&#x27;y&#x27;</span>)<br>        <span class="hljs-built_in">EraseHardDrive</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="getline-的使用">getline 的使用</h2><h3 id="问题与解决方案">问题与解决方案</h3><ul><li>使用 <code>&gt;&gt;</code> 读取可能导致问题，而 <code>getline</code> 可以避免这些问题。</li><li><code>getline</code> 读取直到换行符，并存储在字符串中。</li></ul><h3 id="示例-1">示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">string myStr;<br><span class="hljs-built_in">getline</span>(cin, myStr); <span class="hljs-comment">// 读取一整行</span><br></code></pre></td></tr></table></figure><h3 id="流操作符混用错误">流操作符混用错误</h3><p>与流提取操作符不同，<code>getline</code> 不会跳过流中仍然存在的空白字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> dummyInt;<br>string dummyString;<br><br>cin &gt;&gt; dummyInt; <span class="hljs-comment">// 输入 10回车</span><br><span class="hljs-built_in">getline</span>(cin, dummyString); <span class="hljs-comment">//dummyString的结果为空串</span><br></code></pre></td></tr></table></figure><p>因此<code>getline</code>会找到<code>cin</code>输入中剩下的换行符，读取并丢弃，最后返回空字符串。</p><h2 id="stringstream">stringstream</h2><h3 id="概述和用法">概述和用法</h3><ul><li>头文件：<code>&lt;sstream&gt;</code></li><li>用于在内存中的字符串缓冲区中读写数据。</li></ul><h3 id="示例-2">示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">stringstream myStream;<br>myStream &lt;&lt; <span class="hljs-string">&quot;Hello!&quot;</span> &lt;&lt; <span class="hljs-number">137</span>; <span class="hljs-comment">// 写入数据</span><br>cout &lt;&lt; myStream.<span class="hljs-built_in">str</span>(); <span class="hljs-comment">// 输出数据</span><br></code></pre></td></tr></table></figure><p><strong>另一个示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">stringstream myConverter;<br><span class="hljs-type">int</span> myInt;<br>string myString;<br><span class="hljs-type">double</span> myDouble;<br><br>myConverter &lt;&lt; <span class="hljs-string">&quot;137 Hello 2.71828&quot;</span>;           <span class="hljs-comment">// 插入字符串数据</span><br>myConverter &gt;&gt; myInt &gt;&gt; myString &gt;&gt; myDouble; <span class="hljs-comment">// 提取混合数据</span><br></code></pre></td></tr></table></figure><h2 id="综合实例编写-getinteger-函数">综合实例：编写 getInteger 函数</h2><p>在编写函数 <code>getInteger</code> 时，需要解决用户输入可能引发的两种错误：</p><ol type="1"><li>用户可能会输入非整数，导致 <code>cin</code> 失败。</li><li>用户可能会输入过多的数据，例如 "137 246"，导致操作成功，但留下额外的数据可能会干扰后续读取。</li></ol><p>为解决这些问题，可以采用以下方法：</p><ul><li>使用 <code>getline</code> 从输入中读取整行数据，以便完整接受用户输入。</li><li>将所读数据保存在 <code>stringstream</code> 对象中，然后再从中使用 <code>&gt;&gt;</code> 进行数据提取，同时检查 <code>stringstream</code> 对象的状态。</li><li>读取完数据后，再次使用 <code>&gt;&gt;</code> 从 <code>stringstream</code> 对象中尝试读取数据。如果能够读取数据，说明用户输入过多。</li></ul><p>下面是示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getInteger</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;prompt)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        cout &lt;&lt; prompt;<br>        string line;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">getline</span>(cin, line))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">domain_error</span>(<span class="hljs-string">&quot;读取失败&quot;</span>);<br><br>        <span class="hljs-function">istringstream <span class="hljs-title">iss</span><span class="hljs-params">(line)</span></span>;<br>        <span class="hljs-type">int</span> result;<br>        <span class="hljs-type">char</span> trash;<br>        <span class="hljs-keyword">if</span> (iss &gt;&gt; result &amp;&amp; !(iss &gt;&gt; trash))<br>            <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例代码">示例代码</h2><p><a href="/downloads/streams.zip">点击下载示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Streams</tag>
      
      <tag>C++ I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
